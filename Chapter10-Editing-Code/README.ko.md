# Chapter 10: 코드 편집하기

[English](./README.md) | **한국어**

---

## 💬 질문하기

학습 중 궁금한 점이 있으면 디스코드에서 질문하세요!

[![Discord](https://img.shields.io/badge/Discord-질문하기-5865F2?style=for-the-badge&logo=discord&logoColor=white)](https://discord.gg/TxbJ56hS94)

---

## 🔗 이전 챕터와의 연결

Chapter 09에서 코드를 **읽고 탐색**하는 방법을 배웠습니다. 코드를 이해했으니, 이제 **수정**할 차례입니다.

코드 탐색과 편집의 관계:
```
탐색 (Chapter 09)          편집 (Chapter 10)
┌─────────────────┐        ┌─────────────────┐
│ 코드 읽기       │   →    │ 코드 수정하기    │
│ 구조 이해하기   │   →    │ 기능 추가하기    │
│ 패턴 파악하기   │   →    │ 리팩토링하기    │
│ 버그 위치 찾기  │   →    │ 버그 고치기     │
└─────────────────┘        └─────────────────┘
```

> **이전 챕터 복습**: Glob과 Grep으로 파일을 찾고, 코드를 읽어서 이해했습니다. 이제 그 이해를 바탕으로 실제 수정을 할 수 있습니다.

---

## 이 챕터에서 배우는 것

- Claude에게 코드 수정 시키기
- 탐색 → 계획 → 실행 워크플로우 마스터하기
- 안전하게 편집하기
- 피드백으로 점진적으로 개선하기
- 리팩토링 패턴 활용하기
- TDD 스타일로 품질 보장하기

---

## 왜 필요합니까?

에세이를 쓴다고 상상해보십시오. 모든 문장을 직접 타이핑하는 대신, 조수에게 원하는 것을 말하면 대신 써줍니다. 검토하고, 수정 사항을 제안하면, 수정해줍니다.

Claude로 코드 편집도 똑같이 작동합니다. 원하는 것을 설명하면, Claude가 코드를 쓰고, 검토하고 다듬으면 됩니다.

### 코드 편집의 실제 가치

**전통적인 개발자 vs AI 협업 개발자:**

| 작업 | 전통적 방식 | AI 협업 방식 |
|------|-------------|--------------|
| 버그 수정 | 직접 코드 분석 → 수정 | "이 에러 고쳐줘" → 검토 → 승인 |
| 기능 추가 | 설계 → 코딩 → 테스트 | 설명 → 계획 확인 → 구현 → 테스트 |
| 리팩토링 | 패턴 찾기 → 수동 수정 | "중복 제거해줘" → 자동 적용 |
| 학습 | 문서 읽기 → 시행착오 | "이렇게 바꾸면 어떨까?" → 즉시 피드백 |

> 💡 **비전공자 팁**: 코드를 직접 작성하는 것과 AI에게 지시하는 것의 차이는, 요리를 직접 하는 것과 셰프에게 레시피를 설명하는 것의 차이와 같습니다. 둘 다 맛있는 요리가 나오지만, 방법이 다를 뿐입니다.

**실제 상황 예시:**
- 새 기능을 추가하고 싶은데 어떻게 구현해야 할지 모름
- 코드에 버그가 있어서 빨리 고쳐야 함
- 지저분한 코드를 더 깔끔하게 리팩토링하고 싶음
- 배우는 중이라 어떻게 작성해야 하는지 보고 싶음
- 기존 코드 스타일에 맞게 새 코드를 추가해야 함

**페어 프로그래머가 있다고 생각하십시오:**
- 전통적인 코딩: 모든 것을 직접 타이핑
- Claude와 함께: 원하는 것을 설명하면, Claude가 타이핑하고, 가이드하고 승인

### 코드 편집의 심리학: 두려움을 넘어서

많은 비전공자들이 코드 수정을 두려워합니다:

```
"망가뜨리면 어쩌지?"
    ↓
Git이 있으니까 언제든 되돌릴 수 있어!

"내가 이해 못하는 부분을 건드리면?"
    ↓
Claude에게 먼저 설명해달라고 하면 돼!

"엉뚱한 곳을 고치면?"
    ↓
diff를 보고 확인한 다음에 승인하면 돼!
```

> 🔥 **프로 팁**: 코드 편집에서 가장 중요한 것은 **자신감**입니다. Git과 Claude가 있으면 거의 모든 실수를 되돌릴 수 있습니다. 두려워하지 말고 시도하세요!

---

## 코드 편집의 기본

Claude Code는 직접 코드를 수정할 수 있습니다. 복사-붙여넣기 없이 파일을 바로 고칩니다.

### 간단한 예시

```
> @index.html 제목을 "내 웹사이트"로 바꿔줘
```

Claude가 파일을 열고, 수정하고, 저장합니다.

### 수정 내용 확인: diff 읽는 법

수정 전에 Claude가 변경 내용을 보여줍니다:

```diff
- <h1>Hello World</h1>
+ <h1>내 웹사이트</h1>
```

- 빨간색 (-): 삭제되는 부분
- 초록색 (+): 추가되는 부분

괜찮으면 `Allow`, 싫으면 `Deny`를 선택합니다.

### diff 읽기 심화

실제 diff는 더 복잡할 수 있습니다:

```diff
@@ -15,8 +15,12 @@ function validateEmail(email) {
   if (!email) {
-    return false;
+    return { valid: false, error: "이메일을 입력해주세요" };
   }

+  if (!email.includes('@')) {
+    return { valid: false, error: "올바른 이메일 형식이 아닙니다" };
+  }
+
   const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-  return emailRegex.test(email);
+  return { valid: emailRegex.test(email), error: null };
 }
```

**diff 읽는 방법:**
1. `@@ -15,8 +15,12 @@`: 15번 줄부터, 원래 8줄이 12줄로 변경
2. `-` 줄: 삭제되는 코드
3. `+` 줄: 추가되는 코드
4. 공백으로 시작하는 줄: 변경 없이 컨텍스트로 보여주는 줄

> 💡 **비전공자 팁**: diff를 처음 보면 어렵지만, `-`는 "이건 없어지고", `+`는 "이게 새로 들어와"라고 생각하면 됩니다. 몇 번 보다 보면 익숙해집니다.

---

## 🎯 미니 퀴즈 1: diff 읽기

다음 diff를 보고 질문에 답하세요:

```diff
- const greeting = "Hello";
+ const greeting = "안녕하세요";
+ const farewell = "안녕히 가세요";
```

**Q1: 이 diff는 몇 줄을 삭제하고 몇 줄을 추가하나요?**

<details>
<summary>정답 보기</summary>

**정답**: 1줄 삭제, 2줄 추가

- `-` 줄이 1개: `const greeting = "Hello";` 삭제
- `+` 줄이 2개: 한국어 인사말과 작별 인사 추가

</details>

**Q2: 이 변경 후 `greeting` 변수의 값은 무엇인가요?**

<details>
<summary>정답 보기</summary>

**정답**: "안녕하세요"

원래 "Hello"였던 값이 "안녕하세요"로 변경됩니다.

</details>

---

## 권장 워크플로우: 탐색 → 계획 → 실행

Anthropic에서 권장하는 방법입니다. 이 워크플로우를 따르면 실수를 크게 줄일 수 있습니다.

### 워크플로우 전체 그림

```
┌─────────────────────────────────────────────────────────────┐
│                     코드 편집 워크플로우                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. 탐색 (Explore)         "이 코드가 뭐 하는 거야?"         │
│         ↓                                                   │
│   2. 계획 (Plan)            "이렇게 바꾸면 어떨까?"            │
│         ↓                                                   │
│   3. 실행 (Code)            "좋아, 그대로 해줘"               │
│         ↓                                                   │
│   4. 확인 (Verify)          "테스트 돌려봐"                   │
│         ↓                                                   │
│   5. 반복 (Iterate)         "이 부분만 더 수정해줘"            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 1단계: 탐색 (Explore)

먼저 코드를 이해합니다.

```
> @src/login.js 이 파일이 뭐 하는 파일이야?
```

**좋은 탐색 질문들:**
```
> @src/auth/ 이 폴더의 파일들이 어떻게 연결되어 있어?
> @src/utils/validation.js에서 validateEmail 함수가 어떻게 작동해?
> 이 프로젝트에서 사용자 데이터는 어디서 관리해?
> @src/components/LoginForm.jsx가 어떤 다른 컴포넌트를 사용해?
```

### 2단계: 계획 (Plan)

수정 계획을 세웁니다. **이 단계가 가장 중요합니다.**

```
> 여기에 비밀번호 검증 기능 추가하고 싶어.
> 어떻게 하면 좋을까? 코드 작성하지 말고 계획만.
```

또는 Plan 모드 사용:
```
> /plan
> 비밀번호 검증 기능을 추가하려면 어떻게 해야 할까?
```

**계획 단계에서 확인할 것들:**
1. 어떤 파일들을 수정할 건지
2. 어떤 순서로 수정할 건지
3. 새로 만들어야 하는 파일이 있는지
4. 기존 코드의 어떤 패턴을 따를 건지
5. 테스트는 어떻게 할 건지

### 3단계: 실행 (Code)

계획대로 수정합니다.

```
> 좋아, 그 계획대로 수정해줘.
```

또는 단계별로:
```
> 계획의 1단계만 먼저 해줘.
```

### 4단계: 확인

잘 되는지 확인합니다.

```
> 테스트 돌려서 확인해줘.
```

```
> npm run dev로 실행해서 잘 되는지 봐줘.
```

### 5단계: 반복

필요하면 수정하고 다시 확인합니다.

```
> 대부분 좋은데, 에러 메시지가 너무 딱딱해. 친절하게 바꿔줘.
```

### 왜 이렇게 합니까?

LLM은 요청을 받으면 학습한 패턴 중 가장 적절해 보이는 것을 선택합니다. 하지만 "비밀번호 검증"이라는 요청에도 여러 구현 방식이 있습니다 (정규식, 라이브러리, 커스텀 로직 등). 계획을 먼저 확인하면:
- Claude가 어떤 방향으로 가려는지 미리 알 수 있습니다
- 의도와 다르면 코드 작성 전에 수정할 수 있습니다
- 예상치 못한 부작용을 미리 발견할 수 있습니다

> ⚠️ **주의사항**: 계획 단계를 건너뛰면 Claude가 예상과 다른 방향으로 구현할 수 있습니다. 특히 복잡한 기능일수록 계획이 중요합니다.

---

## 실전 대화 예시: 탐색 → 계획 → 실행

### 예시 1: 기능 추가

```
사용자: @src/components/ProductCard.jsx 이 컴포넌트가 뭐 하는 거야?

Claude: 이 컴포넌트는 상품 정보를 카드 형태로 보여주는 UI 컴포넌트입니다.
        - 상품 이미지, 이름, 가격을 표시
        - 클릭하면 상품 상세 페이지로 이동
        - 현재 '장바구니 담기' 버튼이 없습니다

사용자: 여기에 장바구니 담기 버튼 추가하고 싶어.
        어떻게 하면 좋을까? 코드 작성하지 말고 계획만.

Claude: 좋습니다. 다음과 같이 진행하면 됩니다:

        1. ProductCard.jsx에 버튼 추가
           - 가격 아래에 "장바구니 담기" 버튼 배치

        2. 클릭 핸들러 연결
           - 기존 CartContext의 addToCart 함수 사용
           - @src/context/CartContext.jsx에 이미 정의되어 있음

        3. 로딩/성공 상태 표시 (선택사항)
           - 버튼 클릭 시 잠시 "담는 중..." 표시
           - 완료 후 "담기 완료!" 또는 체크 아이콘

        이 프로젝트의 다른 버튼들(@src/components/Button.jsx)과
        스타일을 일치시키겠습니다.

사용자: 좋아, 근데 로딩 상태는 필요 없을 것 같아.
        1단계랑 2단계만 해줘.

Claude: 네, 버튼과 클릭 핸들러만 추가하겠습니다.
        [diff 표시]

        - CartContext의 addToCart를 import 했습니다
        - 가격 아래에 버튼을 추가했습니다
        - 기존 Button 컴포넌트 스타일을 사용했습니다

사용자: 버튼이 너무 커. 크기 좀 줄여줘.

Claude: 버튼 크기를 줄이겠습니다.
        [diff 표시]

        - size="sm" prop을 추가해서 작은 버튼으로 변경했습니다
```

### 예시 2: 버그 수정

```
사용자: 로그인이 안 돼. 아이디랑 비밀번호 넣고 버튼 눌러도 아무 반응이 없어.

Claude: 로그인 관련 코드를 확인해보겠습니다.

        @src/pages/Login.jsx를 보니, 로그인 버튼에 onClick 핸들러가
        연결되어 있지 않습니다. 버튼 코드가 이렇게 되어 있습니다:

        <button type="button">로그인</button>

        문제점:
        1. onClick 핸들러가 없음
        2. type="submit"이 아니라 "button"으로 되어 있음

        어떻게 수정할까요?

        방법 A: button에 onClick={handleLogin} 추가
        방법 B: type="submit"으로 바꾸고 form에 onSubmit 연결

        이 프로젝트의 다른 폼들은 방법 B를 사용하고 있어서,
        일관성을 위해 방법 B를 추천합니다.

사용자: 방법 B로 해줘.

Claude: [diff 표시]

        수정 완료했습니다:
        - button의 type을 "submit"으로 변경
        - form 태그에 onSubmit={handleLogin} 추가
        - handleLogin에 e.preventDefault() 추가 (페이지 새로고침 방지)

사용자: 테스트해볼게. npm run dev 실행해줘.

Claude: npm run dev를 실행했습니다. http://localhost:3000에서 확인하세요.
        로그인 버튼이 잘 작동하는지 테스트해보세요!
```

### 예시 3: 리팩토링

```
사용자: @src/utils/helpers.js가 너무 길어. 정리 좀 해줘.

Claude: @src/utils/helpers.js를 분석해보겠습니다.

        현재 상태:
        - 총 450줄
        - 25개의 함수가 섞여 있음
        - 문자열 관련: formatDate, formatCurrency, truncateText 등 8개
        - 검증 관련: validateEmail, validatePhone 등 7개
        - 배열 관련: groupBy, sortBy 등 6개
        - 기타: 4개

        분리 계획을 제안합니다:

        @src/utils/
        ├── formatters.js    (문자열 포맷팅 함수들)
        ├── validators.js    (검증 함수들)
        ├── arrayUtils.js    (배열 유틸리티들)
        └── helpers.js       (기타)

        또한 helpers.js에서 모두 re-export해서
        기존에 @src/utils/helpers.js를 import하는 코드는
        수정하지 않아도 되게 하겠습니다.

        이 계획으로 진행할까요?

사용자: 좋아. 근데 한 번에 다 하지 말고,
        formatters.js만 먼저 분리해줘.

Claude: 네, formatters.js만 먼저 분리하겠습니다.

        [새 파일 생성: src/utils/formatters.js]
        [helpers.js에서 해당 함수들 제거하고 import 추가]

        테스트 돌려볼까요?

사용자: 응, 테스트 돌려봐.

Claude: npm test를 실행했습니다.

        모든 테스트 통과! (47 passed)

        다음으로 validators.js를 분리할까요?
```

---

## 피드백으로 개선하기

첫 결과가 완벽하지 않아도 괜찮습니다. 피드백을 주면 개선할 수 있습니다.

### 피드백의 종류

| 피드백 유형 | 예시 | Claude의 반응 |
|------------|------|---------------|
| 스타일 수정 | "버튼 색을 파란색으로" | CSS/스타일 코드만 수정 |
| 기능 수정 | "클릭하면 알림도 띄워줘" | 기능 로직 추가 |
| 구조 수정 | "이 부분을 별도 컴포넌트로" | 파일 분리 및 리팩토링 |
| 삭제 요청 | "이 기능은 필요 없어" | 해당 코드 제거 |
| 되돌리기 | "아까 그거 취소해" | 이전 상태로 복원 |

### 예시

```
> 로그인 폼 만들어줘
```

결과가 나왔는데 마음에 안 들면:

```
> 에러 메시지가 너무 딱딱해. 친절하게 바꿔줘.
```

```
> 버튼이 너무 작아. 크기 키워줘.
```

```
> 비밀번호 입력할 때 눈 아이콘 추가해서 볼 수 있게 해줘.
```

2-3번 피드백 주면 훨씬 좋아집니다.

### 효과적인 피드백 주는 법

**모호한 피드백 (비효과적)**
```
> 이거 별로야
> 더 좋게 해줘
> 뭔가 이상해
```

**구체적인 피드백 (효과적)**
```
> 버튼 색이 배경이랑 잘 안 어울려. 더 진한 파란색으로 바꿔줘.
> 폼 제출 후에 로딩 표시가 없어서 사용자가 버튼을 여러 번 누를 수 있어.
> 에러 메시지가 영어로 나와. 한국어로 바꿔줘.
```

> 💡 **비전공자 팁**: 피드백을 줄 때는 "무엇이 문제인지"와 "어떻게 고쳤으면 좋겠는지"를 함께 말하면 좋습니다. "별로야"보다 "색이 별로야. 더 밝은 색으로 바꿔줘"가 훨씬 효과적입니다.

---

## 되돌리기

잘못됐으면 되돌릴 수 있습니다. 언제든지 실수를 되돌릴 수 있다는 것을 기억하세요!

### 되돌리기 옵션들

| 방법 | 단축키/명령어 | 언제 사용 |
|------|---------------|----------|
| 작업 중단 | `Esc` | Claude가 작업 중일 때 |
| 직전 작업 되돌리기 | `Esc Esc` | 방금 한 변경 취소 |
| 완전 취소 | `Ctrl + C` | 모든 것 취소하고 새로 시작 |
| Git 되돌리기 | "마지막 커밋으로 되돌려줘" | 여러 변경 한번에 취소 |
| 특정 지점으로 | "리팩토링 전 백업으로 되돌려줘" | 특정 커밋으로 이동 |

### 예시

Claude가 이상한 방향으로 가고 있으면:

```
# Esc Esc 누르고
> 아, 그거 말고. 다시 설명할게.
> 기존 로그인 로직은 유지하고, OAuth만 추가해줘.
```

여러 변경이 꼬였으면:

```
> 잠깐, 아까부터 한 것들 다 되돌려줘.
> 마지막 커밋 상태로 가자.
```

### 되돌리기 시나리오별 가이드

**시나리오 1: Claude가 잘못된 파일을 수정했을 때**
```
> 잠깐, Login.jsx 말고 Register.jsx를 수정해야 해.
> 방금 Login.jsx 수정한 거 되돌리고, Register.jsx 수정해줘.
```

**시나리오 2: 수정이 다른 곳을 망가뜨렸을 때**
```
> 이거 수정하니까 장바구니 페이지가 안 돼.
> 뭐가 잘못됐는지 확인하고, 장바구니는 건드리지 않는 방법으로 다시 해줘.
```

**시나리오 3: 전체 방향이 틀렸을 때**
```
> 아니야, 이 접근법이 아닌 것 같아.
> 다 되돌리고, 다른 방법으로 해보자.
```

---

## 좋은 편집 요청 vs 나쁜 요청

### 편집 요청 비교표

| 나쁜 요청 | 왜 나쁜지 | 좋은 요청 |
|----------|----------|----------|
| "버그 고쳐줘" | 어떤 버그인지 모름 | "로그인 버튼이 안 눌려. 고쳐줘" |
| "더 좋게 해줘" | 어떤 점이 부족한지 모름 | "코드 가독성 높여줘" |
| "이거 수정해" | 무엇을 어떻게 수정하는지 모름 | "제목 색을 빨간색으로 바꿔줘" |
| "에러 나" | 어떤 에러인지 모름 | "TypeError: undefined 에러 나" |

### 나쁜 예

```
> 버그 고쳐줘
```
뭘 고쳐야 하는지 모릅니다.

### 좋은 예

```
> @src/utils.js의 validateEmail 함수에서
> "test@" 같은 잘못된 이메일도 통과시키는 버그가 있어.
> 도메인 부분에 점(.)이 있는지 확인하도록 고쳐줘.
```

### 더 좋은 예 (기존 패턴 참조)

```
> @src/utils.js에 validatePhone 함수 추가해줘.
> @src/utils.js의 validateEmail이랑 비슷한 스타일로.
```

기존 코드를 참조하면 일관된 스타일로 작성해줍니다.

### 상황별 좋은 요청 예시

**버그 수정 요청:**
```
> @src/cart/CartItem.jsx에서 수량을 0으로 바꾸면
> 마이너스 가격이 표시돼. 최소 수량을 1로 제한해줘.
```

**기능 추가 요청:**
```
> @src/components/SearchBar.jsx에 검색어 자동완성 추가해줘.
> 현재 프로젝트의 products 데이터에서 이름을 가져와서 보여주면 돼.
```

**스타일 수정 요청:**
```
> @src/pages/Home.jsx의 히어로 섹션 배경색을
> 프로젝트의 primary 색상(#3B82F6)으로 바꿔줘.
```

**리팩토링 요청:**
```
> @src/hooks/useAuth.js가 너무 길어.
> 토큰 관련 로직을 useToken.js로 분리해줘.
> 기존에 useAuth를 사용하는 곳은 수정하지 않아도 되게.
```

---

## TDD 스타일: 테스트 먼저

테스트를 먼저 작성하면 Claude가 정확히 뭘 만들어야 하는지 압니다.

### TDD의 장점

```
전통적 방식:
코드 작성 → 테스트 작성 → 버그 발견 → 코드 수정 → 반복

TDD 방식:
테스트 작성 → 테스트 실패 확인 → 코드 작성 → 테스트 통과 → 완료!
```

테스트가 먼저 있으면:
1. 요구사항이 명확해집니다
2. Claude가 정확히 뭘 만들어야 하는지 알게 됩니다
3. 완료 기준이 분명합니다 (테스트 통과 = 완료)

### 예시

```
# 1단계: 테스트 먼저
> formatDate 함수 테스트 작성해줘.
> "2024-01-15"를 넣으면 "2024년 1월 15일"이 나와야 해.
> 빈 문자열 넣으면 에러 나야 하고.

# 2단계: 테스트 실행 (실패 확인)
> 테스트 돌려봐.

# 3단계: 구현
> 이제 테스트 통과하게 함수 만들어줘.

# 4단계: 다시 확인
> 테스트 다시 돌려봐.
```

### 상세 TDD 예시

```
사용자: formatCurrency 함수의 테스트를 먼저 작성해줘.
        - 1000 → "1,000원"
        - 1500000 → "1,500,000원"
        - 0 → "0원"
        - 음수 → 에러
        - 문자열 → 에러

Claude: 테스트를 작성했습니다.

        @src/utils/__tests__/formatCurrency.test.js
        [테스트 코드 표시]

사용자: 테스트 돌려봐.

Claude: 테스트 실행 결과:
        ✗ formatCurrency is not defined

        5개 테스트 모두 실패했습니다.
        아직 함수가 없기 때문입니다.

사용자: 이제 함수 만들어줘.

Claude: formatCurrency 함수를 만들었습니다.

        @src/utils/formatCurrency.js
        [함수 코드 표시]

        테스트 돌려볼까요?

사용자: 응.

Claude: 테스트 실행 결과:
        ✓ 1000을 "1,000원"으로 변환
        ✓ 1500000을 "1,500,000원"으로 변환
        ✓ 0을 "0원"으로 변환
        ✓ 음수에 에러 발생
        ✓ 문자열에 에러 발생

        5개 테스트 모두 통과!
```

> 🔥 **프로 팁**: TDD는 처음에는 귀찮아 보이지만, 복잡한 기능을 만들 때 엄청난 시간을 절약해줍니다. 테스트가 있으면 리팩토링할 때도 자신감 있게 할 수 있습니다.

---

## 리팩토링 패턴

리팩토링은 코드의 동작은 그대로 유지하면서 구조를 개선하는 것입니다.

### 주요 리팩토링 패턴

| 패턴 | 언제 사용 | 예시 요청 |
|------|----------|----------|
| 함수 추출 | 코드가 너무 길 때 | "이 부분을 함수로 분리해줘" |
| 이름 변경 | 이름이 불명확할 때 | "이 변수 이름 바꿔줘" |
| 파일 이동 | 구조 개선할 때 | "이 파일을 다른 폴더로 옮겨줘" |
| 중복 제거 | 같은 코드가 반복될 때 | "중복 코드 제거해줘" |
| 타입 추가 | 안정성 높일 때 | "TypeScript 타입 추가해줘" |

### 함수 추출

```
> @src/App.js에서 50-70줄의 검증 로직을
> validateForm 함수로 분리해줘.
```

**더 상세하게:**
```
> @src/pages/Checkout.jsx의 handleSubmit 함수가 너무 길어.
> 안에 있는 주소 검증 로직(30-50줄)을 validateAddress 함수로 분리해줘.
> 같은 파일 안에 두고, 나중에 필요하면 따로 빼자.
```

### 이름 변경

```
> getUserData 함수를 fetchUserProfile로 이름 바꿔줘.
> 모든 파일에서.
```

**이름 변경 시 주의사항:**
```
> data 변수를 user로 바꿔줘.
> 근데 @src/api/에 있는 다른 data들은 건드리지 마.
```

### 파일 이동

```
> @src/utils/helpers.js를
> @src/lib/helpers.js로 옮겨줘.
> import 문도 다 업데이트해줘.
```

### 중복 코드 제거

```
> @src/pages/Login.jsx와 @src/pages/Register.jsx에
> 비슷한 폼 검증 코드가 있어. 공통 함수로 만들어줘.
```

### 리팩토링 전후 예시

**리팩토링 전:**
```javascript
// 같은 코드가 여러 곳에서 반복
function handleLogin() {
  if (!email) {
    setError("이메일을 입력하세요");
    return;
  }
  if (!email.includes("@")) {
    setError("올바른 이메일 형식이 아닙니다");
    return;
  }
  // ... 로그인 로직
}

function handleRegister() {
  if (!email) {
    setError("이메일을 입력하세요");
    return;
  }
  if (!email.includes("@")) {
    setError("올바른 이메일 형식이 아닙니다");
    return;
  }
  // ... 가입 로직
}
```

**리팩토링 후:**
```javascript
// 공통 함수로 추출
function validateEmail(email) {
  if (!email) return "이메일을 입력하세요";
  if (!email.includes("@")) return "올바른 이메일 형식이 아닙니다";
  return null;
}

function handleLogin() {
  const emailError = validateEmail(email);
  if (emailError) {
    setError(emailError);
    return;
  }
  // ... 로그인 로직
}

function handleRegister() {
  const emailError = validateEmail(email);
  if (emailError) {
    setError(emailError);
    return;
  }
  // ... 가입 로직
}
```

---

## 🎯 미니 퀴즈 2: 리팩토링 패턴

다음 상황에 어떤 리팩토링 패턴을 사용해야 할까요?

**Q1: 100줄짜리 함수가 있는데, 그 안에서 3가지 다른 작업을 합니다.**

<details>
<summary>정답 보기</summary>

**정답**: 함수 추출

100줄짜리 함수를 3개의 작은 함수로 분리합니다. 각 함수는 한 가지 작업만 담당하게 됩니다.

```
> 이 함수를 3개의 작은 함수로 분리해줘.
> 각 함수가 한 가지 작업만 하도록.
```

</details>

**Q2: `d`라는 변수가 있는데, 뭘 의미하는지 모르겠습니다.**

<details>
<summary>정답 보기</summary>

**정답**: 이름 변경

변수 이름을 의미 있게 바꿉니다.

```
> d 변수가 뭘 의미해?
> 의미를 파악해서 적절한 이름으로 바꿔줘.
```

</details>

**Q3: `utils/helpers.js` 파일에 100개의 함수가 있어서 관리가 어렵습니다.**

<details>
<summary>정답 보기</summary>

**정답**: 파일 이동 (파일 분리)

기능별로 파일을 분리합니다.

```
> helpers.js를 기능별로 여러 파일로 분리해줘.
> 예: validators.js, formatters.js, dateUtils.js 등
> 기존 import는 그대로 동작하게 유지해줘.
```

</details>

---

## 안전하게 편집하기

### Git 활용 - 가장 중요한 안전망

큰 수정 전에 커밋해두십시오.

```
> 지금 상태로 커밋해줘. 리팩토링 시작 전 백업.
```

문제가 생기면:

```
> 뭔가 잘못됐어. 마지막 커밋으로 되돌려줘.
```

### Git 베스트 프랙티스

```
작업 전:
> git status 보여줘

작업 시작 전 백업:
> 현재 상태로 커밋해줘. "리팩토링 전 백업"

작업 중간중간:
> 여기까지 커밋해줘. "함수 추출 완료"

문제 발생 시:
> 마지막 커밋으로 되돌려줘

또는 특정 커밋으로:
> "리팩토링 전 백업" 커밋으로 되돌려줘
```

> ⚠️ **주의사항**: Git 없이 큰 리팩토링을 하면 안 됩니다! 문제가 생겼을 때 되돌릴 방법이 없습니다.

### 권한 모드 활용

| 모드 | 언제 사용 | 설명 |
|------|----------|------|
| **Plan 모드** | 탐색/계획할 때 | 코드 수정 불가, 분석만 가능 |
| **Normal 모드** | 배울 때 | 매번 수정 전 확인 요청 |
| **Accept Edits** | 익숙해졌을 때 | 수정 자동 승인 |

**Plan 모드 활용:**
```
> /plan
> 이 프로젝트 구조 설명해줘.
> 로그인 기능을 추가하려면 어떤 파일들을 수정해야 해?
```

Plan 모드에서는 실수로 코드를 수정할 위험이 없습니다.

### 안전한 편집 체크리스트

- [ ] Git으로 현재 상태 커밋했나?
- [ ] 계획을 먼저 확인했나?
- [ ] diff를 읽고 이해했나?
- [ ] 테스트가 있다면 테스트 통과했나?
- [ ] 다른 곳에 영향 주는지 확인했나?

---

## 📝 실습 과제

### 🟢 초급: 기본 편집

**목표**: 기본적인 코드 편집을 익힙니다.

```
# 파일 만들기
> hello.html 만들어줘. "Hello World" 보여주는 페이지.

# 수정하기
> 제목을 "안녕하세요"로 바꿔줘.

# 추가하기
> 버튼 추가해줘. 클릭하면 alert 나오게.

# 스타일 추가
> 버튼을 예쁘게 꾸며줘. 둥근 모서리에 파란 배경.
```

**확인 포인트:**
- diff를 읽고 이해할 수 있는가?
- 피드백으로 수정 요청을 할 수 있는가?

### 🟡 중급: 탐색 → 계획 → 실행

**목표**: 체계적인 편집 워크플로우를 익힙니다.

```
# 탐색
> @package.json 이 프로젝트 뭐 하는 프로젝트야?

# 계획
> 사용자 프로필 기능 추가하고 싶어. 계획 세워줘.

# 계획 검토
> 2단계가 너무 복잡해 보여. 더 간단한 방법 없어?

# 실행
> 좋아, 수정된 계획의 1단계부터 시작하자.

# 테스트
> 잘 되는지 확인해줘.

# 피드백
> 프로필 사진 업로드도 추가해줘.
```

### 🔴 고급: 리팩토링 프로젝트

**목표**: 실제 코드를 리팩토링하면서 편집 기술을 익힙니다.

```
# 샘플 코드 만들기
> 아래 조건의 legacy.js 만들어줘:
> - 150줄 정도의 복잡한 코드
> - 중복 코드가 있고
> - 함수 이름이 불명확하고
> - 주석이 없고
> - var를 사용하는 레거시 문법

# 분석
> @legacy.js 분석해줘. 개선할 점 리스트 만들어줘.

# 계획
> 개선 순서와 계획을 세워줘.

# 단계별 리팩토링
> 1단계: 중복 코드를 함수로 분리해줘
> [테스트]
> 2단계: 함수 이름을 의미있게 바꿔줘
> [테스트]
> 3단계: var를 let/const로 바꿔줘
> [테스트]
> 4단계: 필요한 곳에 주석 추가해줘
```

---

## 🏆 도전 과제

### 도전 1: 오픈소스 리팩토링

실제 오픈소스 프로젝트에서 리팩토링 해보기:

```bash
git clone https://github.com/sindresorhus/ora.git
cd ora
claude
```

```
> 이 프로젝트 구조 설명해줘
> 개선할 수 있는 부분 찾아줘
> 하나 골라서 리팩토링 계획 세워줘
> [계획 검토 후] 진행해줘
```

### 도전 2: TDD로 기능 구현

테스트 주도 개발로 새 기능 만들기:

```
> 다음 요구사항의 테스트를 먼저 작성해줘:
>
> formatRelativeTime 함수
> - 방금 전 (1분 미만)
> - N분 전 (1시간 미만)
> - N시간 전 (24시간 미만)
> - N일 전 (7일 미만)
> - N주 전 (4주 미만)
> - N개월 전 (12개월 미만)
> - N년 전

> 테스트 돌려봐 (실패 확인)

> 이제 테스트 통과하게 함수 만들어줘

> 테스트 다시 돌려봐

> 엣지 케이스 테스트 추가해줘:
> - 미래 시간 입력
> - 잘못된 형식 입력
```

### 도전 3: 레거시 코드 현대화

오래된 JavaScript를 최신 문법으로 변환:

```
> 이 코드를 ES6+ 문법으로 모던화해줘:
> - var → let/const
> - function → arrow function (적절한 곳만)
> - Promise → async/await
> - 문자열 연결 → 템플릿 리터럴

> TypeScript로 변환해줘. 타입도 제대로 추가하고.

> 단위 테스트 추가해줘. 각 함수마다.
```

---

## 에러 시나리오와 해결책

### 시나리오 1: Claude가 원하지 않는 변경을 했습니다

**상황**: 로그인 버튼 스타일을 바꾸려고 했는데, 전체 페이지 레이아웃까지 바꿔버렸습니다.

```
사용자: 로그인 버튼 색상 바꿔줘.
Claude: [버튼 색상 변경 + 전체 레이아웃 변경]
```

**해결책:**
```
> 잠깐, 너무 많이 바꿨어.
> 버튼 색상만 바꾸고, 레이아웃은 원래대로 돌려줘.
```

또는:
```
# Esc Esc 눌러서 되돌리고
> 버튼 색상"만" 바꿔줘. 다른 건 건드리지 마.
```

### 시나리오 2: 수정 후 다른 곳이 망가졌습니다

**상황**: 로그인 폼을 수정했는데, 회원가입 폼도 같은 컴포넌트를 쓰고 있어서 망가졌습니다.

```
사용자: npm run dev
Claude: 에러! Register.jsx에서 Button 컴포넌트 props 에러
```

**해결책:**
```
> 아, Register.jsx도 같은 Button 컴포넌트를 쓰고 있었구나.
> Register.jsx도 확인해서 같이 수정해줘.
```

### 시나리오 3: Claude가 잘못된 파일을 수정합니다

**상황**: Login.jsx를 수정하라고 했는데, LoginForm.jsx를 수정합니다.

```
사용자: 로그인 페이지 수정해줘
Claude: @src/components/LoginForm.jsx를 수정하겠습니다...
```

**해결책:**
```
> 아니, LoginForm.jsx 말고 @src/pages/Login.jsx를 수정해줘.
> 정확한 파일 경로를 사용하자.
```

### 시나리오 4: 변경이 저장되지 않았습니다

**상황**: 수정했다고 하는데, 파일을 열어보면 변경이 없습니다.

**해결책:**
```
> 파일 저장됐어? @src/login.js 내용 보여줘.
```

Claude가 권한을 물어봤을 때 "Deny"를 선택했을 수 있습니다.
```
> 다시 수정하고 저장해줘. 이번에는 Allow 할게.
```

### 시나리오 5: Claude가 계속 원치 않는 패턴을 사용합니다

**상황**: 인라인 스타일 쓰지 말라고 했는데 계속 씁니다.

**해결책:**

CLAUDE.md에 추가:
```markdown
## 코딩 규칙
- 인라인 스타일 절대 사용하지 않기
- CSS 모듈 또는 styled-components 사용할 것
- 새 의존성 추가 전 반드시 물어볼 것
```

또는 매번 명시:
```
> CSS 모듈로 스타일 추가해줘. 인라인 스타일은 쓰지 마.
```

---

## 자주 하는 실수

### 실수 1: 변경사항 검토 안 하기

```
# 나쁜 예 - 보지도 않고 다 수락
> 이거 더 좋게 해줘
[Claude가 20줄 변경]
[읽지도 않고 Allow 클릭]

# 좋은 예 - 수락 전에 검토
> 이거 더 좋게 해줘
[Claude가 diff 보여줌]
[diff를 주의 깊게 읽음]
[뭔가 잘못된 것 발견]
> 잠깐, 15번 줄 바꾸지 마. 그 부분은 유지해.
```

### 실수 2: 계획 단계 건너뛰기

```
# 나쁜 예 - 바로 코딩으로 점프
> 내 앱에 사용자 인증 추가해줘

# 좋은 예 - 먼저 계획
> /plan
> 사용자 인증 추가하고 싶어. 가장 좋은 접근법이 뭐야?
> [계획 검토]
> 좋아 보여. 시작하자.
```

### 실수 3: 모호한 편집 요청

```
# 나쁜 예
> 버그 고쳐줘

# 좋은 예
> @src/login.js에서 로그인 버튼이 작동 안 해.
> 클릭하면 loginUser 함수를 호출해야 해.
> 현재는 아무 일도 안 일어나.
```

### 실수 4: 안전을 위해 Git 안 쓰기

```
# 나쁜 예 - 안전망 없음
> 전체 코드베이스 리팩토링해줘
[뭔가 망가짐, 복구 방법 없음]

# 좋은 예 - 먼저 커밋
> 현재 변경사항 "리팩토링 전 백업"으로 커밋해줘
> 이제 utils 폴더 리팩토링해줘
[뭔가 망가짐]
> 백업 커밋으로 되돌려줘
```

### 실수 5: 한 번에 너무 많이 수정하기

```
# 나쁜 예
> 이 파일 전체를 TypeScript로 다시 작성해줘

# 좋은 예
> 먼저, 함수 파라미터에만 TypeScript 타입 추가해줘
> [검토]
> 이제 반환 값에 타입 추가해줘
> [검토]
> 이제 user 객체에 인터페이스 추가해줘
```

> 💡 **비전공자 팁**: "작게, 자주"가 핵심입니다. 큰 변경을 한 번에 하려고 하면 문제가 생겼을 때 뭐가 문제인지 찾기 어렵습니다. 작은 변경을 여러 번 하면 각 단계에서 확인할 수 있어서 안전합니다.

---

## 🎯 미니 퀴즈 3: 종합

**Q1: 새 기능을 추가하기 전에 먼저 해야 할 것은?**

A) 바로 코드 작성 시작
B) 계획을 세우고 검토
C) 테스트 작성
D) Git 커밋

<details>
<summary>정답 보기</summary>

**정답**: B와 D 모두!

순서:
1. D) Git 커밋 - 현재 상태 백업
2. B) 계획 세우고 검토 - 방향 확인
3. 그 다음 구현

C) 테스트 작성은 TDD를 할 때 좋지만, 필수는 아닙니다.
A) 바로 코드 작성은 가장 피해야 할 패턴입니다.

</details>

**Q2: Claude가 예상과 다른 방향으로 수정하고 있을 때 어떻게 해야 하나요?**

<details>
<summary>정답 보기</summary>

**정답**:
1. `Esc`를 눌러 작업 중단
2. 원하는 것을 더 명확하게 설명
3. 필요하면 `Esc Esc`로 되돌리기

```
> 잠깐, 멈춰.
> 내가 원한 건 [명확한 설명]이야.
> 다시 해줘.
```

</details>

**Q3: "중복 코드를 함수로 분리해줘"라는 요청이 효과적인 이유는?**

<details>
<summary>정답 보기</summary>

**정답**:
- 무엇을 해야 하는지 명확함 (중복 코드 찾기)
- 어떻게 해야 하는지 명확함 (함수로 분리)
- 결과가 명확함 (중복이 제거된 코드)

더 좋게 만들려면:
```
> @src/pages/Login.jsx와 @src/pages/Register.jsx에 있는
> 이메일 검증 중복 코드를 @src/utils/validation.js의
> validateEmail 함수로 분리해줘.
```

</details>

---

## 용어 정리

| 용어 | 설명 |
|------|------|
| **diff** | 파일의 변경 내용을 보여주는 형식. `-`는 삭제, `+`는 추가 |
| **리팩토링** | 코드의 동작은 유지하면서 구조를 개선하는 것 |
| **TDD** | Test-Driven Development. 테스트를 먼저 작성하고 코드를 작성하는 방식 |
| **함수 추출** | 긴 코드에서 일부를 별도 함수로 분리하는 리팩토링 |
| **Plan 모드** | 코드 수정 없이 분석만 하는 모드 |
| **커밋** | Git에서 현재 상태를 저장하는 것 |
| **되돌리기** | 이전 상태로 복원하는 것 |

---

## 정리

이번 챕터에서 배운 것:
- [x] Claude에게 코드 수정 시키기
- [x] diff 읽고 이해하기
- [x] 탐색 → 계획 → 실행 워크플로우
- [x] 피드백으로 점진적 개선하기
- [x] 되돌리기와 Git 활용
- [x] 리팩토링 패턴
- [x] TDD 스타일 개발
- [x] 안전하게 편집하기

### 핵심 포인트 요약

1. **계획 먼저**: 바로 코딩하지 말고 계획부터
2. **diff 확인**: 변경 내용을 꼭 검토하고 승인
3. **Git 활용**: 큰 수정 전에 꼭 커밋
4. **작게, 자주**: 한 번에 많이 하지 말고 조금씩
5. **구체적 요청**: 모호한 요청 대신 명확한 요청

---

## ➡️ 다음 챕터 미리보기

[Chapter 11: Git 기초](../Chapter11-Git-Basics/README.ko.md)에서는:

- Git의 기본 개념 이해하기
- Claude와 함께 버전 관리하기
- 브랜치 사용법
- 협업 워크플로우

코드 편집을 배웠으니, 이제 편집한 코드를 안전하게 관리하는 방법을 배웁니다!

```
이번 챕터: 코드 편집하기     →     다음 챕터: Git 기초
┌─────────────────────┐          ┌─────────────────────┐
│ 코드 수정           │    →     │ 변경 이력 관리       │
│ 리팩토링            │    →     │ 버전 관리           │
│ 되돌리기            │    →     │ 브랜치              │
└─────────────────────┘          └─────────────────────┘
```

---

## 📖 더 알아보기

### 추천 자료

**공식 문서:**
- [Claude Code 편집 기능](https://docs.anthropic.com/en/docs/claude-code) - 파일 편집 공식 문서
- [Git 공식 문서](https://git-scm.com/doc) - 버전 관리 시스템

**영상 자료:**
- [TDD 입문 (YouTube)](https://www.youtube.com/results?search_query=test+driven+development+tutorial+beginners) - 테스트 주도 개발 기초
- [Refactoring Techniques (YouTube)](https://www.youtube.com/results?search_query=code+refactoring+techniques) - 리팩토링 기법
- [Reading Git Diff (YouTube)](https://www.youtube.com/results?search_query=how+to+read+git+diff) - diff 읽는 방법

**읽을거리:**
- [Refactoring Guru](https://refactoring.guru/refactoring) - 리팩토링 패턴 학습 사이트
- [Martin Fowler's Refactoring](https://martinfowler.com/books/refactoring.html) - 리팩토링 명저

**관련 도구:**
- [Git](https://git-scm.com/) - 버전 관리 시스템
- [GitHub Desktop](https://desktop.github.com/) - Git GUI 클라이언트
- [Jest](https://jestjs.io/) - JavaScript 테스트 프레임워크
- [Prettier](https://prettier.io/) - 코드 포맷터

---

<p align="center">
  <sub>Built with ❤️ by <a href="https://hashed.com">Hashed</a></sub>
</p>
