# Chapter 08: 효과적인 프롬프팅

[English](./README.md) | **한국어**

---

## 💬 질문하기

학습 중 궁금한 점이 있으면 디스코드에서 질문하세요!

[![Discord](https://img.shields.io/badge/Discord-질문하기-5865F2?style=for-the-badge&logo=discord&logoColor=white)](https://discord.gg/TxbJ56hS94)

---

## 🎯 이 챕터의 목표

- 프롬프팅의 **과학적 원리** 이해하기
- **20가지 프롬프팅 패턴** 마스터하기
- **상황별 최적의 프롬프트** 작성법 익히기
- Plan 모드와 Ultrathink **고급 활용** 배우기
- **프롬프트 디버깅** 기법 익히기

---

## ⏱️ 예상 소요 시간

- 읽기: **40분**
- 실습: **60분**

---

## 📋 필요한 것

- Claude Code 설치 및 로그인 완료
- 컨텍스트와 메모리 이해 (Chapter 07)

---

## 🔗 이전 챕터와의 연결

Chapter 07에서 CLAUDE.md로 프로젝트 규칙을 설정하는 법을 배웠습니다. 이제 **매 요청마다** Claude에게 효과적으로 소통하는 방법을 배워봅시다. 좋은 프롬프트는 좋은 CLAUDE.md만큼 중요합니다!

---

## 왜 프롬프팅이 중요합니까?

식당에서 주문한다고 생각해보십시오. "음식 주세요"라고만 하면 직원이 무엇을 원하는지 알 수 없습니다. 하지만 "미디엄으로 구운 스테이크랑 매쉬드 포테이토 주세요"라고 하면 정확히 원하는 것을 받을 수 있습니다.

프롬프팅도 똑같습니다. Claude에게 명확하게 전달할수록 더 좋은 결과를 얻습니다.

**실제 상황 예시:**
- 버그가 있는데 "고쳐줘"라고만 함 - Claude가 뭘 고쳐야 하는지 모름
- 웹사이트 원하는데 "웹사이트 만들어줘"라고만 함 - 어떤 웹사이트인지 모름
- 함수가 필요한데 뭘 해야 하는지 설명 안 함 - Claude가 추측함 (보통 틀림)

> 💡 **비전공자 팁**
>
> **프롬프팅은 길 안내와 같아요:**
> - 나쁜 예: "저쪽으로 가세요" (모호하고 도움 안 됨)
> - 좋은 예: "커피숍에서 좌회전하고, 2블록 직진하세요" (명확하고 실행 가능)
>
> 구체적인 안내가 목적지에 빨리 도착하게 해주듯이,
> 구체적인 프롬프트가 원하는 결과를 빨리 얻게 해줍니다.

---

## 프롬프팅의 과학적 원리

### LLM이 프롬프트를 처리하는 방식

LLM은 다음 단어를 예측하는 방식으로 작동합니다. 프롬프트가 구체적일수록, 예측 범위가 좁아지고 원하는 결과에 가까워집니다.

```
모호한 프롬프트:
"코드 만들어줘" → 무한한 가능성 → 예측 어려움

구체적인 프롬프트:
"React로 이메일 검증 함수 만들어줘.
정규식 사용하고, 에러 메시지 반환해."
→ 좁은 가능성 → 정확한 예측
```

### 프롬프트 품질과 결과의 관계

| 프롬프트 품질 | 예시 | 결과 |
|-------------|------|------|
| 매우 모호 | "고쳐줘" | Claude가 뭘 해야 할지 모름 |
| 모호 | "버튼 고쳐줘" | 어떤 버튼? 뭐가 문제? |
| 보통 | "로그인 버튼이 안 눌려" | 조금 나아짐 |
| 구체적 | "@src/Login.tsx의 버튼 onClick이 작동 안 해" | 정확한 진단 가능 |
| 매우 구체적 | "@src/Login.tsx 15번 줄 onClick, 클릭해도 handleSubmit 호출 안 됨" | 즉시 해결 가능 |

> 🔥 **프로 팁**
>
> **프롬프트의 구체성 = 결과의 정확성**
>
> 1분 더 들여 프롬프트를 구체화하면,
> 10분의 수정 작업을 절약할 수 있습니다.

---

## 좋은 프롬프트의 5가지 원칙

### 1. 구체적으로 표현 (Specific)

```
# 나쁜 예
> 웹사이트 만들어줘

# 좋은 예
> 자기소개 페이지 만들어줘.
> - 이름, 사진, 소개글 섹션 3개
> - 배경은 파란색 그라데이션
> - 반응형으로, 모바일에서도 잘 보이게
> - Tailwind CSS 사용
```

### 2. 맥락 제공 (Context)

```
# 나쁜 예
> 함수 추가해줘

# 좋은 예
> @src/utils.js에 날짜 포맷 함수 추가해줘.
> 다른 함수들과 비슷한 스타일로.
> 입력: "2024-01-15"
> 출력: "2024년 1월 15일"
```

### 3. 한 번에 하나씩 (One at a time)

```
# 나쁜 예
> 로그인 기능 만들고 회원가입도 만들고 비밀번호 찾기도 만들어줘

# 좋은 예
> 먼저 로그인 기능부터 만들자.
> 이메일과 비밀번호 입력받는 폼.
> 제출하면 /api/login으로 POST 요청.
```

### 4. 예시 제공 (Examples)

```
# 나쁜 예
> 날짜 포맷해줘

# 좋은 예
> 날짜를 이렇게 포맷해줘:
> 입력: "2024-01-15" → 출력: "2024년 1월 15일"
> 입력: "2024-12-25" → 출력: "2024년 12월 25일"
```

### 5. 제약사항 명시 (Constraints)

```
# 나쁜 예
> 검증 함수 만들어줘

# 좋은 예
> 이메일 검증 함수 만들어줘.
> - 정규식 사용
> - 빈 문자열이면 false
> - @ 없으면 false
> - 도메인에 . 없으면 false
> - 외부 라이브러리 쓰지 마
```

---

## 20가지 프롬프팅 패턴

### 기본 패턴 (1-5)

#### 1. 역할 지정 패턴

Claude에게 특정 역할을 부여합니다.

```
> 너는 시니어 React 개발자야.
> 코드 리뷰 관점에서 이 컴포넌트 분석해줘.
```

```
> 너는 UX 전문가야.
> 이 폼의 사용성을 개선할 방법 제안해줘.
```

#### 2. 단계별 진행 패턴

복잡한 작업을 단계로 나눕니다.

```
> 쇼핑몰 만들자. 단계별로 하자.
>
> 1단계: 상품 목록 페이지
> 2단계: 상품 상세 페이지
> 3단계: 장바구니
> 4단계: 결제
>
> 먼저 1단계부터 시작하자.
```

#### 3. 참조 패턴

기존 코드를 참조하게 합니다.

```
> @src/components/Button.tsx 이 파일 스타일로
> Input 컴포넌트 만들어줘.
```

```
> @src/api/users.ts 이 파일처럼
> products API도 만들어줘.
```

#### 4. 비교 패턴

선택지를 비교하게 합니다.

```
> 상태 관리로 Redux vs Zustand vs Jotai 중에
> 이 프로젝트에 뭐가 좋을까?
> 장단점 비교해줘.
```

#### 5. 제한 패턴

원하지 않는 것을 명시합니다.

```
> 로그인 폼 만들어줘.
> - 외부 라이브러리 쓰지 마
> - CSS-in-JS 쓰지 마
> - 클래스 컴포넌트 쓰지 마
> Tailwind CSS만 사용해.
```

### 분석 패턴 (6-10)

#### 6. 설명 요청 패턴

코드의 작동 방식을 물어봅니다.

```
> @src/hooks/useAuth.ts
> 이 코드가 뭐 하는 건지 한 줄씩 설명해줘.
> 비전공자도 이해할 수 있게.
```

#### 7. 문제 진단 패턴

에러의 원인을 분석하게 합니다.

```
> 이 에러가 발생해:
> "Cannot read property 'map' of undefined"
>
> @src/ProductList.tsx 이 파일에서
> 왜 이런 에러가 나는지 분석해줘.
```

#### 8. 트레이드오프 분석 패턴

결정의 장단점을 분석하게 합니다.

```
> 이 함수를 async/await으로 바꾸면
> 장점과 단점이 뭐야?
> 현재 콜백 방식과 비교해줘.
```

#### 9. 리뷰 패턴

코드를 검토하게 합니다.

```
> @src/utils/validate.ts
> 이 코드 리뷰해줘.
> - 버그 가능성
> - 성능 문제
> - 가독성 개선점
> 각각 찾아줘.
```

#### 10. 최적화 패턴

성능 개선을 요청합니다.

```
> @src/components/Dashboard.tsx
> 이 컴포넌트가 느려.
> 리렌더링 최적화 방법 찾아줘.
> React.memo, useMemo, useCallback 고려해서.
```

### 생성 패턴 (11-15)

#### 11. 템플릿 패턴

반복 사용할 구조를 만들게 합니다.

```
> CRUD API 엔드포인트 템플릿 만들어줘.
> 나중에 users, products, orders에 재사용할 거야.
```

#### 12. 확장 패턴

기존 코드에 기능을 추가합니다.

```
> @src/Button.tsx
> 이 버튼에 로딩 상태 추가해줘.
> isLoading prop 받으면 스피너 보여주게.
```

#### 13. 변환 패턴

코드를 다른 형태로 변환합니다.

```
> @src/utils.js
> 이 JavaScript 파일을 TypeScript로 변환해줘.
> 타입도 제대로 정의해줘.
```

#### 14. 테스트 생성 패턴

테스트 코드를 만들게 합니다.

```
> @src/utils/calculate.ts
> 이 함수들의 단위 테스트 만들어줘.
> Jest 사용, 엣지 케이스 포함.
```

#### 15. 문서화 패턴

문서를 생성하게 합니다.

```
> @src/api/
> 이 폴더의 모든 API 함수를
> JSDoc 형식으로 문서화해줘.
```

### 고급 패턴 (16-20)

#### 16. 시뮬레이션 패턴

상황을 가정하고 대응하게 합니다.

```
> 이 로그인 시스템에서 발생할 수 있는
> 보안 취약점을 가정하고 대응책 제시해줘.
```

#### 17. 디버깅 가이드 패턴

디버깅 과정을 안내받습니다.

```
> 폼 제출이 안 돼.
> 원인을 찾기 위해 어디를 확인해야 해?
> 단계별 체크리스트 만들어줘.
```

#### 18. 리팩토링 패턴

코드 구조를 개선하게 합니다.

```
> @src/pages/Dashboard.tsx
> 이 파일이 500줄이야.
> 컴포넌트를 분리해서 리팩토링해줘.
> 각 컴포넌트가 단일 책임을 갖도록.
```

#### 19. 마이그레이션 패턴

기술 스택을 변경합니다.

```
> 이 프로젝트를 React 17에서 18로 마이그레이션해줘.
> 필요한 변경사항 목록 만들고
> 하나씩 적용해줘.
```

#### 20. 아키텍처 패턴

전체 구조를 설계하게 합니다.

```
> ultrathink
> 이 쇼핑몰 프로젝트의 폴더 구조와
> 컴포넌트 아키텍처를 설계해줘.
> 확장성과 유지보수성을 고려해서.
```

---

## Plan 모드 심층 활용

Plan 모드는 Claude가 실행하기 전에 계획을 세우게 합니다.

### Plan 모드가 중요한 이유

LLM은 요청을 받으면 바로 가장 적절해 보이는 방향으로 생성을 시작합니다. 하지만 이 "적절해 보이는"이 항상 여러분의 의도와 일치하지는 않습니다.

```
# Plan 모드 없이
> 인증 시스템 만들어줘

[Claude가 바로 JWT 기반으로 구현 시작]
[근데 나는 세션 기반을 원했음...]
[다 만든 후 다시 해야 함 😱]
```

```
# Plan 모드 사용
> /plan
> 인증 시스템 만들어줘

Claude: 인증 시스템 구현 계획:
1. JWT vs 세션 중 선택
2. 로그인/로그아웃 API
3. 보호된 라우트 미들웨어
...
어떤 방식을 선호하시나요?

> 세션 기반으로 해줘
[정확히 원하는 방향으로 진행!]
```

### 사용법

```
> /plan
```
또는 `Shift + Tab` 두 번

### Plan 모드 활용 패턴

#### 패턴 1: 대규모 기능 개발

```
> /plan
> 결제 시스템 만들어줘.
> Stripe 연동이고, 구독과 일회성 결제 둘 다 지원해야 해.

Claude: 결제 시스템 구현 계획:

1단계: Stripe 설정
- API 키 설정
- Webhook 엔드포인트

2단계: 일회성 결제
- 결제 폼 UI
- Checkout Session 생성
- 결제 완료 처리

3단계: 구독 결제
- 구독 플랜 정의
- 구독 생성/취소
- 구독 상태 관리

이 순서로 진행할까요?
```

#### 패턴 2: 리팩토링 전 검토

```
> /plan
> @src/pages/Dashboard.tsx
> 이 500줄 파일을 리팩토링하고 싶어.
> 어떻게 나누면 좋을까?

Claude: 리팩토링 계획:

현재 구조 분석:
- 차트 렌더링 (100줄)
- 통계 계산 (80줄)
- 필터 로직 (70줄)
- 데이터 페칭 (50줄)
- UI 레이아웃 (200줄)

제안하는 분리:
1. DashboardLayout.tsx - 레이아웃
2. StatisticsPanel.tsx - 통계
3. ChartSection.tsx - 차트
4. useFilters.ts - 필터 훅
5. useDashboardData.ts - 데이터 훅

이렇게 진행할까요?
```

#### 패턴 3: 기술 선택

```
> /plan
> 폼 검증 라이브러리를 도입하려고 해.
> react-hook-form, formik, Zod 중에 뭐가 좋을까?

Claude: 폼 검증 라이브러리 비교:

react-hook-form:
- 장점: 성능 좋음, 작은 번들
- 단점: 학습 곡선

Formik:
- 장점: 직관적, 문서 좋음
- 단점: 리렌더링 많음

Zod:
- 장점: 타입 안전, 재사용
- 단점: 별도 폼 라이브러리 필요

이 프로젝트 특성상 react-hook-form + Zod 조합을 추천합니다.
이유: TypeScript 사용 중이고, 폼이 많아서 성능이 중요해 보입니다.

이 조합으로 진행할까요?
```

> 💡 **비전공자 팁**
>
> **Plan 모드를 언제 사용해야 할까요?**
>
> - 새로운 기능 개발할 때
> - 큰 변경 작업 전에
> - 여러 방법 중 선택해야 할 때
> - 복잡한 리팩토링 전에
>
> 작은 수정(버그 픽스, 텍스트 변경)에는 불필요합니다.

---

## Ultrathink: 복잡한 문제 해결

LLM은 응답을 생성할 때 내부적으로 "추론 과정"을 거칩니다. 복잡한 문제일수록 더 많은 추론이 필요합니다. 특정 키워드를 사용하면 Claude가 더 많은 추론 시간을 사용하도록 유도할 수 있습니다.

### 쉬운 비유: 시험 문제 풀기

```
┌─────────────────────────────────────────────────────────────────┐
│                  Ultrathink = 시험 시간 늘려주기                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  📝 간단한 문제: "1 + 1 = ?"                                     │
│     → 바로 답: 2 (생각할 필요 없음)                               │
│     → 키워드 없이 요청                                           │
│                                                                 │
│  📝 보통 문제: "이 코드 버그 찾아줘"                               │
│     → 코드 읽고 → 분석하고 → 답변                                 │
│     → "think" 키워드                                            │
│                                                                 │
│  📝 어려운 문제: "이 시스템 아키텍처 설계해줘"                      │
│     → 요구사항 파악 → 여러 옵션 검토 → 장단점 분석 → 결정          │
│     → "ultrathink" 키워드                                       │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  💰 비용: 생각 많이 할수록 비용 증가                               │
│     간단한 질문에 ultrathink 쓰면 = 1+1 푸는데 3시간 쓴 격       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

> 💡 **비전공자 팁**
>
> ultrathink는 **"더 깊이 생각해"**라는 지시입니다.
>
> 의사가 환자를 볼 때:
> - 감기 증상 → 바로 진단 (기본)
> - 복잡한 증상 → 여러 검사 후 판단 (think hard)
> - 희귀 질환 의심 → 전문의 상담, 논문 검토 (ultrathink)
>
> Claude도 마찬가지예요. 복잡한 문제에만 ultrathink를 사용하세요!

### 키워드 단계

| 키워드 | 추론 깊이 | 사용 시점 | 토큰 사용량 |
|--------|----------|-----------|------------|
| (없음) | 기본 | 간단한 작업 | 낮음 |
| `think` | 보통 | 일반적인 작업 | 보통 |
| `think hard` | 깊음 | 복잡한 문제 | 높음 |
| `ultrathink` | 최대 | 아키텍처 결정 | 매우 높음 |

### Ultrathink 사용 예시

#### 아키텍처 설계

```
> ultrathink
> 이 프로젝트 구조를 어떻게 설계하면 좋을까?
> - 현재: 모놀리식 Next.js 앱
> - 요구사항: 마이크로서비스로 전환 준비
> - 제약: 점진적 마이그레이션 필요
> 나중에 기능 추가하기 쉽게.
```

#### 복잡한 버그 분석

```
> ultrathink
> 이 버그 분석해줘:
> - 증상: 가끔 결제가 두 번 됨
> - 재현: 네트워크 느릴 때
> - 관련 파일: @src/payment/checkout.ts
> 근본 원인과 해결책 찾아줘.
```

#### 성능 최적화

```
> ultrathink
> @src/components/DataGrid.tsx
> 10,000행 표시할 때 버벅임.
> 가상화, 메모이제이션, 청크 로딩 등
> 모든 옵션 검토하고 최적의 해결책 제시해줘.
```

> ⚠️ **주의사항**
>
> ultrathink는 **토큰을 많이 소모**합니다.
> 간단한 작업에는 사용하지 마세요.
>
> **사용해야 할 때:**
> - 전체 아키텍처 결정
> - 복잡한 버그 분석
> - 여러 시스템이 얽힌 문제
>
> **사용 안 해도 될 때:**
> - 단순 코드 생성
> - 텍스트 수정
> - 기본적인 버그 수정

---

## 상황별 최적의 프롬프트

### 버그 수정

```
# 기본
> @src/login.js에서 로그인 버튼 누르면 에러 발생.
> "Cannot read property 'email' of undefined"
> 수정해줘.

# 더 나은 버전
> 버그 수정 요청:
>
> 파일: @src/login.js
> 증상: 로그인 버튼 클릭 시 에러
> 에러: "Cannot read property 'email' of undefined"
> 재현: 이메일 입력 안 하고 버튼 클릭
>
> 원인 분석하고 수정해줘.
> 비슷한 버그 방지할 방어 코드도 추가해줘.
```

### 새 기능 구현

```
# 기본
> 다크모드 만들어줘

# 더 나은 버전
> 다크모드 기능 추가해줘.
>
> 요구사항:
> - 토글 버튼으로 전환
> - 시스템 설정 감지 (prefers-color-scheme)
> - localStorage에 선택 저장
> - 페이지 새로고침해도 유지
>
> 참고: @src/components/Header.tsx에 토글 버튼 추가
> 스타일: Tailwind dark: 클래스 사용
```

### 코드 리팩토링

```
# 기본
> 이 코드 정리해줘

# 더 나은 버전
> @src/utils/validation.ts 리팩토링해줘.
>
> 현재 문제:
> - 함수가 너무 김 (100줄 이상)
> - 중복 코드 많음
> - 테스트하기 어려움
>
> 요청:
> 1. 함수 분리 (각각 20줄 이내)
> 2. 중복 제거
> 3. 순수 함수로 변경
> 4. 기존 동작 유지 확인
```

### API 연동

```
# 기본
> API 연결해줘

# 더 나은 버전
> 사용자 API 연동해줘.
>
> 엔드포인트:
> - GET /api/users - 목록 조회
> - GET /api/users/:id - 상세 조회
> - POST /api/users - 생성
> - PUT /api/users/:id - 수정
> - DELETE /api/users/:id - 삭제
>
> 요구사항:
> - React Query 사용
> - 에러 처리 (toast 알림)
> - 로딩 상태 표시
> - TypeScript 타입 정의
>
> @src/types/User.ts 참고해서 타입 사용
```

---

## 프롬프트 디버깅

결과가 원하는 대로 나오지 않을 때, 프롬프트를 디버깅하는 방법입니다.

### 진단 체크리스트

원하는 결과가 나오지 않으면 다음을 확인하세요:

| 확인 항목 | 질문 | 해결 방법 |
|----------|------|----------|
| 구체성 | 너무 모호하지 않은가? | 파일명, 줄 번호, 구체적 요구사항 추가 |
| 맥락 | 필요한 배경 정보를 제공했는가? | 관련 파일 `@`로 참조 |
| 범위 | 한 번에 너무 많이 요청했는가? | 작업 분할 |
| 예시 | 원하는 형태를 보여줬는가? | 입력/출력 예시 추가 |
| 제약 | 하지 말아야 할 것을 명시했는가? | 제약사항 추가 |

### 디버깅 예시

**문제: Claude가 원하지 않는 라이브러리 사용**

```
# 원래 프롬프트
> 폼 검증 추가해줘

# Claude가 Yup 라이브러리 사용함 (원하지 않음)

# 수정된 프롬프트
> 폼 검증 추가해줘.
> 외부 라이브러리 쓰지 말고 순수 JavaScript로.
> 정규식 사용해서 직접 구현해.
```

**문제: 결과가 기존 코드 스타일과 다름**

```
# 원래 프롬프트
> Input 컴포넌트 만들어줘

# Claude가 다른 스타일로 작성함

# 수정된 프롬프트
> @src/components/Button.tsx 스타일로
> Input 컴포넌트 만들어줘.
> 같은 패턴, 같은 프롭 구조로.
```

**문제: 너무 복잡한 결과물**

```
# 원래 프롬프트
> 유저 프로필 페이지 만들어줘

# Claude가 10개 파일 생성, 복잡한 상태 관리...

# 수정된 프롬프트
> 유저 프로필 페이지 만들어줘.
> 단순하게.
> 파일 1개로.
> 상태 관리 없이.
> 정적 UI만.
```

### 반복 개선 패턴

```
1차 시도:
> 로그인 폼 만들어줘
→ 결과가 너무 단순함

2차 시도 (구체화):
> 로그인 폼 만들어줘.
> 이메일, 비밀번호 필드.
> 에러 메시지 표시.
> 로딩 상태 표시.
→ 결과가 좀 나아짐, 하지만 스타일이 다름

3차 시도 (참조 추가):
> @src/components/SignupForm.tsx 스타일로
> 로그인 폼 만들어줘.
> 이메일, 비밀번호 필드.
> 에러 메시지와 로딩 상태 포함.
→ 원하는 결과!
```

> 🔥 **프로 팁**
>
> **프롬프트 개선은 반복 과정입니다.**
>
> 첫 번째 시도에서 완벽한 결과를 기대하지 마세요.
> 결과를 보고, 프롬프트를 조금씩 개선하는 게 효율적입니다.
>
> 보통 2-3번의 반복이면 원하는 결과를 얻을 수 있습니다.

---

## 🎯 미니 퀴즈

### 퀴즈 1
다음 중 가장 **좋은** 프롬프트는?

A) "코드 고쳐줘"
B) "버그 고쳐줘"
C) "@src/login.js 42줄 null 에러 고쳐줘"
D) "문제 해결해줘"

<details>
<summary>정답 보기</summary>

**정답: C**

파일명, 줄 번호, 에러 유형을 **구체적으로** 명시했습니다.
Claude가 정확히 무엇을 해야 하는지 알 수 있습니다.

</details>

### 퀴즈 2
Plan 모드를 사용해야 하는 상황으로 **가장 적절한** 것은?

A) 오타 수정
B) 전체 결제 시스템 구현
C) 버튼 색상 변경
D) 주석 추가

<details>
<summary>정답 보기</summary>

**정답: B**

Plan 모드는 **대규모, 복잡한 기능**을 구현할 때 사용합니다.
결제 시스템은 여러 단계와 결정이 필요한 복잡한 기능입니다.
나머지는 간단한 수정이라 Plan 모드가 필요 없습니다.

</details>

### 퀴즈 3
다음 프롬프트의 문제점은?

```
> 로그인, 회원가입, 비밀번호 찾기, 프로필 수정,
> 알림 설정, 결제 연동 다 만들어줘
```

<details>
<summary>정답 보기</summary>

**문제점: 한 번에 너무 많이 요청**

6개의 기능을 한 번에 요청하면:
- 각 기능의 완성도가 떨어짐
- 중간에 방향 수정이 어려움
- 에러 발생 시 원인 파악이 어려움

**해결: 한 번에 하나씩 요청**

</details>

---

## 📝 실습 과제

### 🟢 초급: 구체적인 프롬프트 작성

다음 나쁜 프롬프트를 좋은 프롬프트로 변환하세요.

```
# 나쁜 프롬프트
> 에러 고쳐줘

# 좋은 프롬프트로 변환해보세요
> ???
```

힌트: 파일명, 에러 메시지, 재현 방법을 포함하세요.

### 🟡 중급: Plan 모드 활용

```
> /plan
> 블로그 시스템을 만들고 싶어.
> 글 목록, 글 상세, 글 작성 기능이 필요해.
> 어떻게 진행하면 좋을까?
```

Claude의 계획을 확인하고, 마음에 들면 실행해보세요.

### 🔴 고급: 프롬프트 디버깅

의도적으로 모호한 프롬프트로 시작해서, 3번의 반복을 통해 원하는 결과를 얻어보세요.

```
# 1차
> 폼 만들어줘

# 2차 (결과 보고 개선)
> ???

# 3차 (결과 보고 개선)
> ???
```

---

## 🏆 도전 과제

### 도전 1: 20가지 패턴 모두 사용해보기

각 패턴을 최소 1번씩 사용해보고, 가장 유용했던 패턴 Top 5를 선정해보세요.

### 도전 2: 프롬프트 라이브러리 만들기

자주 사용하는 프롬프트를 모아서 개인 라이브러리를 만들어보세요.

```markdown
# 나의 프롬프트 라이브러리

## 버그 수정
> 파일: @[파일명]
> 증상: [설명]
> 에러: [에러메시지]
> 재현: [재현방법]
> 수정해줘.

## 컴포넌트 생성
> @[참고파일] 스타일로
> [컴포넌트명] 만들어줘.
> [요구사항 목록]

...
```

### 도전 3: Ultrathink 실험

복잡한 문제에 ultrathink를 사용해보고, 일반 모드와 결과 품질을 비교해보세요.

---

## 실제 대화 예시

### 예시 1: 단계별 개선

```
# 1단계: 모호한 요청
> 버튼 만들어줘

[Claude가 기본 버튼 생성]

# 2단계: 스타일 개선
> 더 예쁘게. 둥글고, 호버 효과 추가.

[Claude가 스타일 개선]

# 3단계: 기능 추가
> 로딩 상태도 추가해. isLoading이 true면 스피너 보여줘.

[Claude가 로딩 기능 추가]

# 4단계: 변형 추가
> variant 프롭 추가해. primary, secondary, danger 세 가지.

[완성된 버튼 컴포넌트!]
```

### 예시 2: Plan 모드로 대규모 기능

```
> /plan
> 이 블로그에 댓글 시스템 추가하고 싶어.

Claude: 댓글 시스템 구현 계획:

1단계: 데이터 모델
- Comment 타입 정의
- API 엔드포인트 설계

2단계: 백엔드
- GET /api/comments - 댓글 목록
- POST /api/comments - 댓글 작성
- DELETE /api/comments/:id - 댓글 삭제

3단계: 프론트엔드
- CommentList 컴포넌트
- CommentForm 컴포넌트
- useComments 훅

4단계: 기능 확장
- 대댓글 지원
- 수정 기능

어떤 순서로 진행할까요?

> 좋아, 1단계부터 시작하자.

[Claude가 1단계 구현]

> 다음 단계 진행해.

[Claude가 2단계 구현]

...
```

### 예시 3: 복잡한 버그 분석

```
> ultrathink
> 이상한 버그가 있어.
>
> 증상:
> - 상품 목록에서 장바구니 추가하면 가끔 두 번 추가됨
> - 항상은 아니고 가끔
> - 네트워크 느릴 때 더 자주 발생
>
> 관련 파일:
> @src/components/ProductCard.tsx
> @src/hooks/useCart.ts
> @src/api/cart.ts
>
> 근본 원인 찾고 해결책 제시해줘.

Claude: [상세한 분석 진행]

분석 결과:

근본 원인:
addToCart 함수에서 중복 요청 방지 로직이 없음.
버튼 더블 클릭 또는 네트워크 지연 시
동일한 요청이 여러 번 전송됨.

영향 범위:
- ProductCard의 onClick
- useCart의 addToCart
- API 레벨 중복 방지 없음

해결책:

1단계: 버튼 레벨 방지
- 클릭 후 버튼 비활성화
- 로딩 상태 표시

2단계: 훅 레벨 방지
- 진행 중인 요청 추적
- 중복 요청 차단

3단계: API 레벨 방지
- 멱등성 키 사용
- 서버에서 중복 체크

어떤 레벨부터 적용할까요?
```

---

## 🚨 흔한 에러와 해결법

### 에러 1: "Claude가 예상과 다르게 동작"

**상황:** 프롬프트를 줬는데 전혀 다른 결과

**원인:** 프롬프트가 너무 모호하거나, Claude가 다르게 해석

**해결:**
- 프롬프트에 예시 추가
- 원하지 않는 것 명시
- Plan 모드로 먼저 확인

```
> 버튼 만들어줘. 예시:
> <Button variant="primary">저장</Button>
>
> - 외부 라이브러리 쓰지 마
> - 인라인 스타일 쓰지 마
```

### 에러 2: "결과가 너무 복잡함"

**상황:** 간단한 걸 요청했는데 10개 파일 생성

**원인:** 프롬프트에 범위 제한이 없음

**해결:**
```
> 버튼 만들어줘.
> 이 파일 하나에서 해결하고, 추가 파일 만들지 마.
> 최대한 단순하게.
```

### 에러 3: "기존 스타일과 안 맞음"

**상황:** 새 코드가 프로젝트 스타일과 다름

**원인:** 참조할 파일을 제공하지 않음

**해결:**
```
> @src/components/Button.tsx 스타일로
> Input 컴포넌트 만들어줘.
```

### 에러 4: "중간에 방향이 틀어짐"

**상황:** 대화가 길어지면서 원래 목표에서 벗어남

**원인:** 맥락을 잃음

**해결:**
```
> 잠깐, 정리하자.
> 원래 목표: 로그인 폼 만들기
> 지금까지 한 것: 이메일 필드
> 다음: 비밀번호 필드와 제출 버튼
>
> 다시 진행하자.
```

---

## ❌ 자주 하는 실수

### 1. 너무 모호하게 말하기

```
# 나쁜 예
> 코드 고쳐줘

# 좋은 예
> @src/login.js 42번 줄에서 이메일 검증이 실패해.
> "test@"처럼 도메인 없는 것도 통과시켜. 이거 고쳐줘.
```

### 2. 한 번에 모든 것 요청하기

```
# 나쁜 예
> 사용자 인증, 결제, 재고, 관리자 패널,
> 분석까지 있는 완전한 쇼핑몰 만들어줘

# 좋은 예
> 사용자 등록부터 시작하자.
> 지금은 회원가입 폼만.
```

### 3. 예시 제공 안 하기

```
# 나쁜 예
> 날짜 예쁘게 포맷해줘

# 좋은 예
> 날짜를 이렇게 포맷해줘: "2024년 1월 15일"
> 입력: "2024-01-15"
> 출력: "2024년 1월 15일"
```

### 4. 제약사항 언급 안 하기

```
# 나쁜 예
> 폼 검증 추가해줘

# 좋은 예
> 폼 검증 추가해줘.
> - 이메일은 @와 도메인이 있어야 함
> - 비밀번호는 최소 8자
> - 에러 메시지는 각 필드 아래 빨간색으로
> - 외부 라이브러리 사용 안 함
```

### 5. 결과 확인 없이 계속 진행

```
# 나쁜 예
> A 만들어줘
> B도 만들어줘
> C도 만들어줘
[확인 없이 계속...]

# 좋은 예
> A 만들어줘
[결과 확인]
> 좋아! 이제 B 만들어줘
[결과 확인]
> 잘 됐어. C도 만들어줘
```

---

## 🆘 안 되면?

| 증상 | 해결 방법 |
|------|----------|
| 원하는 대로 안 됨 | 프롬프트 더 구체적으로 |
| 너무 복잡한 결과 | "단순하게", "파일 1개로" 추가 |
| 스타일이 다름 | 기존 파일 `@`로 참조 |
| 방향이 잘못됨 | Esc Esc로 되돌리고 다시 요청 |
| 복잡한 문제 못 품 | ultrathink 사용 |
| 시작 전 확인 필요 | /plan 사용 |

---

## 📚 관련 용어 사전

| 용어 | 설명 |
|------|------|
| **프롬프트 (Prompt)** | AI에게 보내는 요청/지시 |
| **프롬프트 엔지니어링** | 효과적인 프롬프트 작성 기술 |
| **Plan 모드** | 실행 전 계획을 세우는 모드 |
| **Ultrathink** | 깊은 추론을 유도하는 키워드 |
| **토큰** | AI가 텍스트를 처리하는 단위 |
| **컨텍스트** | 대화의 맥락, 배경 정보 |

---

## ✅ 체크리스트

학습을 마치기 전에 확인하세요:

- [ ] 좋은 프롬프트의 5가지 원칙을 안다
- [ ] 최소 10개 이상의 프롬프팅 패턴을 사용할 수 있다
- [ ] Plan 모드를 언제, 어떻게 사용하는지 안다
- [ ] Ultrathink를 언제 사용하는지 안다
- [ ] 프롬프트 디버깅 방법을 안다
- [ ] 상황별 최적의 프롬프트를 작성할 수 있다

---

## ➡️ 다음 단계 미리보기

다음 챕터에서는 **코드 탐색하기**를 학습합니다.

배우게 될 내용:
- 코드 리딩의 중요성
- Glob과 Grep 검색 전략
- 대규모 코드베이스 탐색
- 프로젝트 분석 기법

[Chapter 09: 코드 탐색하기](../Chapter09-Exploring-Code/README.ko.md)로 진행하십시오.

---

## 📖 더 알아보기

### 추천 자료

**공식 문서:**
- [Claude Code 사용 가이드](https://docs.anthropic.com/en/docs/claude-code) - 공식 사용법 문서
- [Anthropic Prompt Engineering Guide](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering) - 프롬프트 엔지니어링 공식 가이드
- [Claude Extended Thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking) - Ultrathink/확장 사고 기능

**영상 자료:**
- [Prompt Engineering 기초 (YouTube)](https://www.youtube.com/results?search_query=prompt+engineering+tutorial+beginners) - 프롬프팅 기초 강의
- [Claude AI Prompting Tips (YouTube)](https://www.youtube.com/results?search_query=claude+ai+prompting+tips) - Claude 프롬프팅 팁

**읽을거리:**
- [Anthropic Prompt Library](https://docs.anthropic.com/en/prompt-library/library) - 프롬프트 예시 라이브러리
- [Chain of Thought Prompting](https://www.anthropic.com/news/claude-2-1-prompting) - 단계별 추론 프롬프팅

**커뮤니티:**
- [Anthropic Discord](https://discord.gg/anthropic) - 커뮤니티 질문 및 토론
- [r/ClaudeAI](https://www.reddit.com/r/ClaudeAI/) - Reddit 커뮤니티

---

<p align="center">
  <sub>Built with ❤️ by <a href="https://hashed.com">Hashed</a></sub>
</p>
