# Chapter 11: Git 기초

[English](./README.md) | **한국어**

---

## 💬 질문하기

학습 중 궁금한 점이 있으면 디스코드에서 질문하세요!

[![Discord](https://img.shields.io/badge/Discord-질문하기-5865F2?style=for-the-badge&logo=discord&logoColor=white)](https://discord.gg/TxbJ56hS94)

---

## 이 챕터에서 배우는 것

- Git이 무엇이고 왜 필수적인지
- Claude로 커밋하고 버전 관리하기
- 브랜치와 PR로 안전하게 협업하기
- 충돌 해결의 실전 노하우

---

## 이전 챕터와의 연결

Chapter 10에서 우리는 프롬프트 작성법과 Claude와 효과적으로 대화하는 방법을 배웠습니다. 이제 본격적인 프로젝트를 시작하기 전에, **코드를 안전하게 관리하는 방법**을 배워야 합니다.

왜냐하면, 아무리 훌륭한 코드를 작성해도 실수로 삭제하거나 잘못 수정하면 모든 노력이 물거품이 되기 때문입니다. Git은 이런 비극을 막아주는 **코드의 안전망**입니다.

---

## Git이 무엇입니까?

Git은 코드의 버전을 관리하는 도구입니다. 하지만 이 한 문장으로는 Git의 진정한 가치를 이해하기 어렵습니다.

### 현실에서의 Git

실제로 Git이 없었다면 어떤 일이 벌어졌을지 상상해봅시다:

**시나리오 1: 혼자 작업할 때**
```
my_project_v1.zip
my_project_v2.zip
my_project_v2_final.zip
my_project_v2_final_진짜최종.zip
my_project_v2_final_진짜최종_수정.zip
```

이런 폴더명 본 적 있으시죠? Git 없이 버전을 관리하려 했던 흔적입니다. 어떤 게 진짜 최신인지, 언제 뭘 바꿨는지 아무도 모릅니다.

**시나리오 2: 팀으로 작업할 때**
```
"내가 수정한 파일 보냈어!"
"어? 나도 그 파일 수정했는데... 덮어씌워졌잖아!"
"누가 내 코드 지웠어?!"
```

협업의 악몽입니다. Git은 이 모든 문제를 해결합니다.

### 왜 필요합니까?

| 상황 | Git 없이 | Git과 함께 |
|------|---------|-----------|
| **되돌리기** | 중요한 코드 실수로 삭제 → 복구 불가 | 한 명령으로 이전 버전 복원 |
| **협업** | "이 파일 수정 중이니까 건드리지 마" | 동시에 같은 파일 작업 후 자동 병합 |
| **기록** | "이거 누가 왜 바꾼 거야?" | 누가 언제 뭘 왜 바꿨는지 전부 기록 |
| **실험** | 새 기능 시도하다 망하면 처음부터 다시 | 브랜치에서 안전하게 실험 후 병합 |

> 💡 **비전공자 팁**: Git을 "코드를 위한 타임머신"이라고 생각하세요. 과거로 돌아갈 수 있고, 평행 세계(브랜치)도 만들 수 있습니다!

### Git의 멘탈 모델

**비디오 게임의 세이브 파일처럼 생각하세요:**

```
🎮 게임                    📁 Git
-----------------------------------------
세이브 포인트        =     커밋 (Commit)
다른 스토리라인      =     브랜치 (Branch)
세이브 불러오기      =     체크아웃 (Checkout)
게임 오버 후 복구    =     리셋 (Reset)
```

- 각 커밋 = 돌아갈 수 있는 세이브 포인트
- 각 브랜치 = 탐험할 수 있는 다른 스토리라인
- 망쳤을 때 = 마지막 세이브 불러오기

### 기본 개념

| 용어 | 뜻 | 쉬운 비유 |
|------|-----|----------|
| **Repository (저장소)** | Git으로 관리되는 프로젝트 폴더 | 게임 전체 |
| **Commit** | 변경 사항을 저장하는 것 | 게임 저장 |
| **Branch** | 독립적인 작업 공간 | 다른 엔딩 루트 |
| **Push** | 내 컴퓨터 → 서버로 업로드 | 클라우드 세이브 |
| **Pull** | 서버 → 내 컴퓨터로 다운로드 | 세이브 불러오기 |
| **Merge** | 브랜치 합치기 | 스토리라인 통합 |

> ⚠️ **주의사항**: Git은 "설치"와 "사용"이 다릅니다. Git이 컴퓨터에 설치되어 있어도, 각 프로젝트 폴더에서 `git init`으로 초기화해야 사용할 수 있습니다.

---

## GitHub이 무엇입니까?

**GitHub**은 Git 저장소를 온라인에 저장하고 공유하는 클라우드 서비스입니다.

### Git vs GitHub

| Git | GitHub |
|-----|--------|
| 내 컴퓨터의 도구 | 웹사이트 (github.com) |
| 버전 기록 관리 | 코드를 온라인에 저장 |
| 오프라인 작업 가능 | 협업 가능 |
| 무료 소프트웨어 | 무료 + 유료 플랜 |
| 명령어 기반 | GUI 제공 |

**비유**: Git은 카메라(사진 찍기), GitHub은 사진 공유 사이트(저장하고 공유)와 같습니다.

> 💡 **비전공자 팁**: Git은 Microsoft Word의 "변경 내용 추적" 기능이고, GitHub은 Google Drive 같은 클라우드 저장소라고 생각하면 됩니다. 둘 다 있어야 완전한 협업이 가능합니다.

### GitHub에서 할 수 있는 것

- **백업**: 코드를 클라우드에 저장 (컴퓨터가 고장나도 안전)
- **협업**: 다른 사람들과 같은 프로젝트 작업
- **오픈소스**: 코드를 공개적으로 공유
- **Pull Request**: 코드를 합치기 전에 리뷰 요청
- **Issues**: 버그와 기능 요청 추적
- **Actions**: 자동화된 테스트와 배포

### GitHub에 연결하기

```
> 이 프로젝트를 GitHub에 연결해줘
```

Claude가:
1. GitHub 로그인 여부 확인
2. 필요시 저장소 생성
3. 코드 푸시

**더 구체적인 요청:**

```
> 이 프로젝트를 GitHub에 올려줘.
> - 저장소 이름: my-first-project
> - Public으로 만들어줘
> - README.md도 포함해줘
```

> 🔥 **프로 팁**: GitHub 저장소를 만들 때 Private과 Public의 차이를 이해하세요. Public은 누구나 볼 수 있고, Private은 초대한 사람만 볼 수 있습니다. 포트폴리오용이라면 Public, 회사 프로젝트라면 Private이 일반적입니다.

---

## Git 설치 확인

```
> git 설치되어 있어?
```

Claude가 터미널 명령어를 실행해서 확인합니다. 설치가 안 되어 있으면 운영체제에 맞는 설치 방법도 안내합니다.

### 설치 확인 대화 예시

**성공 케이스:**
```
사용자: git 설치되어 있어?

Claude: Git 버전을 확인해볼게요.
[실행: git --version]

출력: git version 2.42.0

네, Git 2.42.0 버전이 설치되어 있습니다.
바로 사용할 수 있는 상태예요.
```

**실패 케이스 (미설치):**
```
사용자: git 설치되어 있어?

Claude: Git 버전을 확인해볼게요.
[실행: git --version]

출력: 'git'은(는) 내부 또는 외부 명령, 실행할 수 있는 프로그램,
또는 배치 파일이 아닙니다.

Git이 설치되어 있지 않네요.
Windows에서 설치하는 방법을 알려드릴게요:

1. https://git-scm.com/download/win 접속
2. "Click here to download" 클릭
3. 설치 프로그램 실행 (기본 설정 그대로 Next)
4. 설치 완료 후 터미널 재시작

설치하시겠어요?
```

> 💡 **비전공자 팁**: 설치 중 나오는 옵션들은 대부분 기본값으로 두셔도 됩니다. 단, "Adjusting your PATH environment"에서는 "Git from the command line and also from 3rd-party software"를 선택하세요.

---

## 커밋하기

커밋은 "현재 상태를 저장"하는 것입니다. 게임의 세이브 포인트와 같습니다.

### 커밋의 중요성

커밋을 자주 하면:
- 문제가 생겼을 때 최근 정상 상태로 돌아갈 수 있음
- 변경 내역을 명확하게 추적할 수 있음
- 팀원들이 무슨 작업을 했는지 알 수 있음

커밋을 안 하면:
- 실수하면 처음부터 다시
- "어제 뭐 바꿨지?" 기억에 의존
- 협업 시 혼란

> ⚠️ **주의사항**: 커밋은 "로컬 저장"입니다. GitHub에 올리려면 Push가 필요합니다. 커밋만 하고 Push 안 하면 내 컴퓨터에만 저장되어 있는 겁니다!

### Claude에게 커밋 시키기

```
> 지금까지 변경한 거 커밋해줘
```

Claude가:
1. 뭐가 바뀌었는지 확인 (`git status`)
2. 변경 내용 분석 (`git diff`)
3. 적절한 커밋 메시지 작성
4. 커밋 실행

**실제 대화 예시:**

```
사용자: 지금까지 변경한 거 커밋해줘

Claude: 먼저 변경 사항을 확인해볼게요.

[실행: git status]

변경된 파일:
- src/App.jsx (수정됨)
- src/components/Button.jsx (새 파일)
- src/styles/button.css (새 파일)

버튼 컴포넌트를 추가한 것 같네요.
다음과 같이 커밋할게요:

[실행: git add .]
[실행: git commit -m "feat: 버튼 컴포넌트 추가

- Button.jsx 컴포넌트 생성
- 버튼 스타일 CSS 추가
- App.jsx에서 버튼 사용"]

✅ 커밋 완료!
커밋 해시: a1b2c3d
```

**더 좋은 커밋 메시지를 원한다면:**

```
> 변경사항 커밋해줘. Conventional Commits 형식으로.
> 이번 변경은 버그 수정이야.
```

맥락을 알려주면 더 정확한 메시지가 나옵니다. "새 기능", "버그 수정", "리팩토링" 같은 힌트를 주세요.

### 커밋 메시지 형식

Claude는 이런 형식으로 커밋 메시지를 씁니다:

```
feat: 로그인 기능 추가

- 이메일/비밀번호 입력 폼 생성
- 로그인 API 연동
```

**타입 종류:**

| 타입 | 의미 | 예시 |
|------|------|------|
| `feat` | 새 기능 | 회원가입 폼 추가 |
| `fix` | 버그 수정 | 로그인 안 되는 버그 수정 |
| `docs` | 문서 변경 | README 업데이트 |
| `style` | 코드 스타일 (동작 변화 없음) | 들여쓰기 정리 |
| `refactor` | 리팩토링 | 함수 분리 |
| `test` | 테스트 추가/수정 | 로그인 테스트 추가 |
| `chore` | 기타 (빌드, 설정 등) | 패키지 업데이트 |

> 🔥 **프로 팁**: 좋은 커밋 메시지는 "무엇을"보다 "왜"를 설명합니다. "버튼 색상 변경"보다 "접근성 개선을 위해 버튼 색상 대비 높임"이 더 좋습니다.

### 커밋 빈도

**언제 커밋해야 합니까?**

```
✅ 좋은 커밋 타이밍:
- 하나의 기능이 완성됐을 때
- 버그를 수정했을 때
- 의미 있는 변경을 했을 때
- 퇴근/휴식 전에

❌ 나쁜 커밋 타이밍:
- 일주일 치 작업을 한 번에
- 코드가 깨진 상태로
- "아직 안 됨"이라는 메시지로
```

> 💡 **비전공자 팁**: "작업 중" 커밋도 괜찮습니다. 완벽하지 않아도 자주 저장하는 게 안전합니다. 나중에 정리할 수 있습니다.

---

## 상태 확인하기

### 현재 상태 보기

```
> git 상태 확인해줘
```

Claude가 `git status`를 실행해서 보여줍니다:
- 수정된 파일
- 새로 추가된 파일
- 삭제된 파일
- 커밋 안 된 변경사항

**실제 대화 예시:**

```
사용자: git 상태 확인해줘

Claude: [실행: git status]

현재 브랜치: main

변경된 파일 (staged 아님):
  modified:   src/App.jsx
  modified:   src/styles/app.css

추적되지 않는 새 파일:
  src/components/Header.jsx
  src/components/Footer.jsx

3개의 변경 사항이 커밋되지 않았어요.
커밋하시겠어요?
```

### 변경 내용 보기

```
> 뭐가 바뀌었는지 보여줘
```

Claude가 `git diff`로 변경 내용을 보여줍니다.

**실제 대화 예시:**

```
사용자: App.jsx에서 뭐가 바뀌었는지 보여줘

Claude: [실행: git diff src/App.jsx]

@@ -5,6 +5,7 @@
 function App() {
   return (
     <div>
+      <Header />      // 이 줄이 추가됨
       <h1>Hello World</h1>
+      <Footer />      // 이 줄이 추가됨
     </div>
   )
 }

Header와 Footer 컴포넌트를 추가했네요.
```

> 💡 **비전공자 팁**: diff에서 `+`는 추가된 줄, `-`는 삭제된 줄입니다. 초록색과 빨간색으로 표시되기도 합니다.

---

## 브랜치 사용하기

브랜치는 "작업 공간"입니다. 메인 코드에 영향을 주지 않고 따로 작업할 수 있습니다.

### 브랜치가 필요한 이유

실제 상황을 상상해봅시다:

```
상황: 웹사이트가 잘 돌아가고 있음
할 일: 새로운 로그인 기능 추가

❌ 브랜치 없이:
1. main에서 직접 작업 시작
2. 로그인 기능 반쯤 만듦 (아직 작동 안 함)
3. 긴급! 기존 페이지 버그 발견!
4. 로그인 코드와 버그 수정이 뒤섞임
5. 뭘 배포해야 할지 혼란 😱

✅ 브랜치 사용:
1. feature/login 브랜치 생성
2. 로그인 기능 작업 중
3. 긴급 버그 → main으로 이동, 수정, 배포
4. 다시 feature/login으로 이동, 계속 작업
5. 완료 후 main에 병합 🎉
```

### 브랜치 네이밍 컨벤션

| 접두어 | 용도 | 예시 |
|-------|------|------|
| `feature/` | 새 기능 | feature/login |
| `fix/` | 버그 수정 | fix/header-overlap |
| `hotfix/` | 긴급 수정 | hotfix/security-patch |
| `refactor/` | 코드 개선 | refactor/api-cleanup |

### 브랜치 만들기

```
> 로그인 기능 만들 브랜치 만들어줘
```

Claude가 `git checkout -b feature/login` 같은 명령어를 실행합니다.

**실제 대화 예시:**

```
사용자: 로그인 기능 만들 브랜치 만들어줘

Claude: 새 브랜치를 만들게요.

[실행: git checkout -b feature/login]

✅ 'feature/login' 브랜치를 만들고 이동했습니다.

현재 상태:
- 이전 브랜치: main
- 현재 브랜치: feature/login

이제 이 브랜치에서 로그인 기능을 자유롭게 작업하세요.
main 브랜치는 영향받지 않습니다.
```

### 브랜치 확인

```
> 지금 어떤 브랜치야?
```

```
> 브랜치 목록 보여줘
```

**실제 대화 예시:**

```
사용자: 브랜치 목록 보여줘

Claude: [실행: git branch -a]

브랜치 목록:
* feature/login      <- 현재 브랜치
  main
  feature/signup

원격 브랜치:
  origin/main
  origin/feature/signup

총 5개 브랜치가 있어요.
현재는 feature/login 브랜치에 계십니다.
```

### 브랜치 전환

```
> main 브랜치로 이동해줘
```

**주의해야 할 상황:**

```
사용자: main으로 이동해줘

Claude: [실행: git checkout main]

⚠️ 잠깐요! 커밋되지 않은 변경사항이 있어요:
- src/Login.jsx (수정됨)

옵션:
1. 변경사항 커밋하고 이동
2. 변경사항 임시 저장(stash)하고 이동
3. 변경사항 버리고 이동 (주의: 복구 불가)

어떻게 할까요?
```

> ⚠️ **주의사항**: 커밋하지 않은 변경사항이 있는 상태에서 브랜치를 바꾸면 변경사항이 따라올 수 있거나, 충돌이 날 수 있습니다. 항상 커밋하거나 stash한 후 이동하세요.

---

## Pull Request (PR) 만들기

PR은 "내 변경사항을 메인에 합쳐달라"고 요청하는 것입니다.

### PR이 필요한 이유

- **코드 리뷰**: 다른 사람이 코드를 검토할 수 있음
- **안전한 병합**: 충돌이나 버그를 미리 발견
- **문서화**: 왜 이 변경을 했는지 기록
- **협업**: 팀원들이 변경 내용을 파악

### Claude에게 PR 시키기

```
> 이 브랜치로 PR 만들어줘
```

Claude가:
1. 변경사항 분석
2. PR 제목과 설명 작성
3. GitHub에 PR 생성

**실제 대화 예시:**

```
사용자: 이 브랜치로 PR 만들어줘

Claude: PR을 만들기 전에 변경사항을 확인할게요.

[실행: git log main..HEAD]

이 브랜치의 커밋들:
1. feat: 로그인 폼 UI 구현
2. feat: 로그인 API 연동
3. fix: 비밀번호 유효성 검사 버그 수정

PR을 생성할게요:

[실행: gh pr create --title "feat: 로그인 기능 추가" --body "..."]

✅ PR이 생성되었습니다!
URL: https://github.com/user/repo/pull/42

리뷰어를 지정하시겠어요?
```

### PR 형식

```markdown
## Summary
- 로그인 폼 UI 구현
- 이메일/비밀번호 검증 추가
- 로그인 API 연동

## Test Plan
- [x] 정상 로그인 테스트
- [x] 잘못된 비밀번호 테스트
- [x] 이메일 형식 검증 테스트

## Screenshots
(있다면 스크린샷 첨부)
```

> 🔥 **프로 팁**: PR 설명에 "왜" 이 변경이 필요한지 적으면 리뷰어가 더 쉽게 이해합니다. 단순히 "로그인 추가"보다 "사용자 인증을 위해 이메일 기반 로그인 시스템을 구현했습니다"가 더 좋습니다.

---

## 충돌 해결하기

여러 사람이 같은 파일을 수정하면 "충돌"이 날 수 있습니다.

### 충돌이 발생하는 이유

```
상황:
1. A가 main에서 feature-a 브랜치를 만듦
2. B도 main에서 feature-b 브랜치를 만듦
3. A와 B가 같은 파일의 같은 줄을 다르게 수정
4. A가 먼저 main에 병합
5. B가 병합하려고 하면 → 충돌!

Git이 묻는다: "둘 중 어떤 버전을 쓸까요?"
```

### 충돌이 나면

```
> 머지 충돌 났어. 해결해줘.
```

Claude가:
1. 각 버전이 뭔지 설명
2. 어떻게 합칠지 제안
3. 수정 적용

**실제 대화 예시 (상세):**

```
사용자: 머지 충돌 났어. 해결해줘.

Claude: 충돌 내용을 확인해볼게요.

[실행: git status]

충돌 파일:
- src/App.jsx

충돌 내용을 보여드릴게요:

<<<<<<< HEAD (현재 브랜치)
function App() {
  return <div className="app-blue">Hello</div>
}
=======
function App() {
  return <div className="app-green">Hello</div>
}
>>>>>>> main (병합하려는 브랜치)

현재 브랜치: 파란색 배경을 적용
main 브랜치: 초록색 배경을 적용

어떻게 해결할까요?
1. 현재 브랜치(파란색) 유지
2. main 브랜치(초록색) 유지
3. 둘 다 사용 (예: 조건부로)
4. 직접 지정

사용자: 파란색으로 해줘

Claude: 파란색 버전을 유지하고 충돌을 해결할게요.

[파일 수정 후]
[실행: git add src/App.jsx]
[실행: git commit -m "resolve: App.jsx 충돌 해결 (파란색 배경 유지)"]

✅ 충돌이 해결되었습니다.
```

**충돌 해결 요청 팁:**

```
> 충돌 해결해줘. 내 브랜치의 로그인 로직을 유지하고 싶어.
> 두 버전 모두 필요해. 합쳐줘.
```

어떤 버전을 선호하는지, 또는 둘 다 필요한지 알려주면 의도에 맞게 해결합니다.

> ⚠️ **주의사항**: 충돌 해결할 때 실수로 다른 사람의 코드를 지우지 않도록 주의하세요. 충돌 마커(`<<<<<<<`, `=======`, `>>>>>>>`)를 전부 제거해야 합니다.

---

## Git 안전 규칙

Claude는 위험한 git 명령어 전에 물어봅니다.

### 안전한 명령어 (자동 실행 가능)

- `git status` - 상태 확인
- `git diff` - 변경 내용 보기
- `git log` - 기록 보기
- `git add` - 파일 추가
- `git commit` - 커밋하기
- `git branch` - 브랜치 확인
- `git checkout` - 브랜치 이동

### 위험한 명령어 (확인 필요)

| 명령어 | 위험도 | 이유 |
|--------|--------|------|
| `git push` | 🟡 중간 | 서버로 업로드 (되돌리기 어려움) |
| `git push --force` | 🔴 매우 높음 | 서버 기록 덮어쓰기 |
| `git reset --hard` | 🔴 매우 높음 | 변경사항 영구 삭제 |
| `git clean -fd` | 🔴 매우 높음 | 추적 안 된 파일 삭제 |
| `git rebase` | 🟡 중간 | 커밋 기록 변경 |

**실제 대화 예시:**

```
사용자: 마지막 커밋 취소하고 싶어

Claude: 마지막 커밋을 취소하는 방법이 여러 가지 있어요:

1. 커밋만 취소하고 변경 내용은 유지 (안전)
   git reset --soft HEAD~1

2. 커밋과 staging을 취소하고 변경 내용은 유지 (안전)
   git reset --mixed HEAD~1

3. 커밋과 모든 변경 내용을 삭제 (⚠️ 위험)
   git reset --hard HEAD~1

어떤 방식으로 할까요?
추천: 1번 (변경 내용을 유지하면서 커밋만 취소)
```

---

## 🎯 미니 퀴즈

개념을 잘 이해했는지 확인해봅시다!

### 퀴즈 1
Q: `git commit`과 `git push`의 차이는 무엇입니까?

<details>
<summary>정답 보기</summary>

- `git commit`: 내 컴퓨터에 변경사항 저장 (로컬 저장)
- `git push`: 저장한 커밋을 서버(GitHub)로 업로드

커밋만 하면 내 컴퓨터에만 있고, 푸시해야 GitHub에 올라갑니다.
</details>

### 퀴즈 2
Q: 브랜치를 사용하는 가장 큰 이유는?

<details>
<summary>정답 보기</summary>

메인 코드(main 브랜치)에 영향을 주지 않고 안전하게 새 기능을 개발할 수 있기 때문입니다. 작업 중인 코드가 불안정해도 main은 항상 정상 작동합니다.
</details>

### 퀴즈 3
Q: "git status"를 실행했을 때 "nothing to commit, working tree clean"이 나왔다면?

<details>
<summary>정답 보기</summary>

마지막 커밋 이후로 변경된 파일이 없다는 뜻입니다. 새로 커밋할 내용이 없는 깨끗한 상태입니다.
</details>

---

## 📝 실습 과제

### 난이도 1: 기본 워크플로우 (초급)

```
# 1. 새 폴더 만들고 Git 초기화
> my-project 폴더 만들고 git 초기화해줘

# 2. 파일 만들기
> index.html 만들어줘

# 3. 커밋하기
> 커밋해줘

# 4. 파일 수정하기
> 제목 바꿔줘

# 5. 다시 커밋
> 변경사항 커밋해줘

# 6. 히스토리 확인
> 커밋 히스토리 보여줘
```

**완료 체크:**
- [ ] 폴더가 git 저장소로 초기화됨
- [ ] 최소 2개의 커밋이 있음
- [ ] `git log`로 커밋 기록 확인 가능

### 난이도 2: 브랜치 사용 (중급)

```
# 1. 새 브랜치 만들기
> feature/button 브랜치 만들어줘

# 2. 파일 수정
> 버튼 추가해줘

# 3. 커밋
> 커밋해줘

# 4. main으로 돌아가기
> main 브랜치로 이동해줘

# 5. 확인
> 버튼이 있어? (없어야 정상 - 다른 브랜치에 있으니까)

# 6. 브랜치 목록 확인
> 브랜치 목록 보여줘
```

**완료 체크:**
- [ ] 새 브랜치가 생성됨
- [ ] 브랜치에서 커밋이 됨
- [ ] main에서는 변경사항이 안 보임
- [ ] 브랜치 전환이 자유로움

### 난이도 3: GitHub 연동 (고급)

```
# 1. GitHub 저장소 만들고 연결
> 이 프로젝트를 GitHub에 올려줘. 저장소 이름은 git-practice로.

# 2. 변경하고 커밋
> README에 내 이름 추가해줘
> 커밋해줘

# 3. 푸시
> GitHub에 푸시해줘

# 4. 브랜치 만들어서 PR
> feature/about-me 브랜치 만들어줘
> 자기소개 섹션 추가해줘
> 커밋하고 PR 만들어줘
```

**완료 체크:**
- [ ] GitHub에 저장소가 생성됨
- [ ] 로컬 커밋이 GitHub에 반영됨
- [ ] PR이 생성됨

---

## 🏆 도전 과제

Git을 더 깊이 이해하고 싶다면 도전해보세요!

### 도전 1: 커밋 메시지 고고학
```
> 마지막 10개 커밋 히스토리를 보여줘.
> 각 커밋에서 어떤 파일이 바뀌었는지도 알려줘.
```

### 도전 2: 시간 여행
```
> 3개 전 커밋의 index.html이 어땠는지 보여줘
> (되돌리지 말고 보기만)
```

### 도전 3: 충돌 시뮬레이션
일부러 충돌을 만들고 해결해보세요:
```
# 브랜치 A에서 header 수정
# 브랜치 B에서 같은 header 다르게 수정
# 병합 시도 → 충돌!
# 충돌 해결
```

---

## 문제가 발생하면

**"not a git repository" 에러가 나옵니까?**
- Git 폴더에 있지 않습니다. 먼저 초기화하세요:
- Claude에게: "이 폴더에 git 초기화해줘"

**"nothing to commit" 메시지가 나옵니까?**
- 마지막 커밋 이후 파일을 변경하지 않았습니다
- 먼저 변경하고, 그 다음 커밋하세요

**머지할 때 "conflict"가 발생합니까?**
- 두 브랜치가 같은 줄을 수정했습니다
- Claude에게: "이 머지 충돌 해결해줘"

**실수로 잘못된 것을 커밋했습니까?**
- 당황하지 마세요. "마지막 커밋 취소하고 변경사항은 유지해줘"
- 또는: "마지막 5개 커밋 보여줘"로 어디로 돌아갈지 찾기

**푸시하면 안 되는 것을 푸시했습니까?**
- 주의: 이건 되돌리기 어렵습니다
- 민감한 파일은 팀장에게 연락하세요
- 코드 실수는: 고치는 새 커밋 만들기

**Git 명령어가 헷갈립니까?**
- 외울 필요 없습니다!
- Claude에게 원하는 것을 말하세요: "내 변경사항 보고 싶어" 또는 "작업 저장해줘"

**"Permission denied" 에러가 나옵니까?**
- GitHub 인증 문제입니다
- Claude에게: "GitHub 인증 설정 도와줘"

---

## 자주 하는 실수

### 실수 1: 정기적으로 커밋 안 하기

```
# ❌ 나쁜 예 - 며칠 작업 후 하나의 거대한 커밋
> 모든 변경사항 "작업함"으로 커밋해줘

# ✅ 좋은 예 - 작고 자주 커밋
> 로그인 폼 커밋해줘
> 검증 커밋해줘
> 에러 처리 커밋해줘
```

**왜 문제입니까?**
- 문제가 생기면 어디서 잘못됐는지 찾기 어려움
- 되돌릴 때 다른 좋은 변경도 함께 없어짐
- 히스토리가 의미 없어짐

### 실수 2: 모호한 커밋 메시지

```
# ❌ 나쁜 예
> "고침"으로 커밋해줘
> "수정"으로 커밋해줘
> "업데이트"로 커밋해줘

# ✅ 좋은 예
> 커밋해줘. 이메일 검증 버그 수정한 거야.
> 커밋해줘. 로그인 폼에 비밀번호 표시 토글 추가했어.
```

**왜 문제입니까?**
- 나중에 "그때 뭘 바꿨지?" 할 때 알 수 없음
- 팀원들이 변경 의도를 모름

### 실수 3: 모든 것을 Main 브랜치에서 작업

```
# ❌ 나쁜 예 - 모든 변경을 main에 직접
> [main에서 변경]
> 커밋

# ✅ 좋은 예 - 기능에 브랜치 사용
> 새 기능용 브랜치 만들어줘
> [변경]
> 커밋
> main에 머지하는 PR 만들어줘
```

**왜 문제입니까?**
- main이 항상 불안정한 상태
- 배포할 수 있는 깨끗한 버전이 없음
- 협업 시 혼란

### 실수 4: 커밋 전에 상태 확인 안 하기

```
# ❌ 나쁜 예 - 맹목적으로 모든 것 커밋
> 모든 변경사항 커밋해줘

# ✅ 좋은 예 - 뭘 커밋하는지 확인
> 어떤 파일이 바뀌었어?
> [목록 검토]
> 로그인 관련 파일만 커밋해줘
```

**왜 문제입니까?**
- 임시 파일이나 테스트 파일이 섞여 들어감
- .env 같은 비밀 파일이 커밋될 수 있음

### 실수 5: .gitignore 설정 안 하기

```
# ❌ 나쁜 예 - node_modules를 커밋
(수천 개의 파일이 GitHub에 올라감)

# ✅ 좋은 예 - .gitignore 설정
> .gitignore 파일 만들어줘. node_modules랑 .env 무시하게.
```

**왜 문제입니까?**
- 저장소가 엄청 커짐
- 푸시/풀이 느려짐
- 비밀 정보 노출 위험

---

## 용어 사전

| 용어 | 설명 |
|------|------|
| **Repository (Repo)** | Git으로 관리되는 프로젝트 폴더 |
| **Commit** | 변경사항을 저장하는 단위 |
| **Branch** | 독립적인 작업 공간 |
| **Merge** | 브랜치를 합치는 것 |
| **Pull Request (PR)** | 코드 병합을 요청하는 것 |
| **Clone** | 원격 저장소를 복사해오는 것 |
| **Fork** | 다른 사람의 저장소를 내 계정으로 복사 |
| **Staging** | 커밋할 파일을 선택하는 것 |
| **HEAD** | 현재 작업 중인 커밋 |
| **Origin** | 원격 저장소의 기본 이름 |

---

## 정리

이번 챕터에서 배운 것:
- [x] Git이 무엇이고 왜 필수적인지
- [x] 커밋으로 변경사항 저장하기
- [x] 상태와 변경 내용 확인하기
- [x] 브랜치로 안전하게 작업하기
- [x] PR로 코드 병합 요청하기
- [x] 충돌 해결하는 방법

Git 명령어를 외울 필요는 없습니다. 중요한 건 **개념을 이해하는 것**입니다. "커밋은 세이브 포인트", "브랜치는 작업 공간" 같은 개념을 알면, Claude에게 의도를 전달할 수 있고, Claude는 그에 맞는 명령어를 실행합니다.

> 💡 **핵심 포인트**: Git은 실수를 두려워하지 않게 해줍니다. 언제든 되돌릴 수 있다는 안전망이 있으면, 더 과감하게 실험하고 배울 수 있습니다.

---

## 다음 챕터 미리보기

Chapter 12에서는 **프로젝트 메모리 (CLAUDE.md)**를 배웁니다.

지금까지 Claude와 대화할 때마다 프로젝트 설정을 반복해서 설명해야 했죠? CLAUDE.md를 사용하면 Claude가 프로젝트 규칙을 "기억"해서, 매번 같은 설명을 반복하지 않아도 됩니다.

Git이 **코드의 기억**이라면, CLAUDE.md는 **AI의 기억**입니다.

[Chapter 12: 프로젝트 메모리](../Chapter12-Project-Memory/README.ko.md)로 넘어가세요.

---

## 📖 더 알아보기

### 추천 자료

**공식 문서:**
- [Git 공식 문서](https://git-scm.com/doc) - Git 완전 가이드
- [GitHub 가이드](https://docs.github.com/ko) - GitHub 공식 한글 문서
- [Pro Git Book (한글)](https://git-scm.com/book/ko/v2) - 무료 Git 교과서

**영상 자료:**
- [Git 입문 튜토리얼 (YouTube)](https://www.youtube.com/results?search_query=git+tutorial+beginners+korean) - Git 기초 강의
- [GitHub 사용법 (YouTube)](https://www.youtube.com/results?search_query=github+tutorial+korean) - GitHub 활용 강의

**읽을거리:**
- [생활코딩 Git](https://opentutorials.org/course/3837) - 초보자 친화적 Git 강의
- [Git 브랜치 배우기](https://learngitbranching.js.org/?locale=ko) - 인터랙티브 Git 학습

**관련 도구:**
- [GitHub Desktop](https://desktop.github.com/) - Git GUI 클라이언트
- [GitKraken](https://www.gitkraken.com/) - 시각적 Git 클라이언트
- [Sourcetree](https://www.sourcetreeapp.com/) - 무료 Git GUI

---

<p align="center">
  <sub>Built with ❤️ by <a href="https://hashed.com">Hashed</a></sub>
</p>
