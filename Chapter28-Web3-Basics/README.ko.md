# Chapter 28: Web3 기초

## 💬 질문하기
[Discord](https://discord.gg/TxbJ56hS94) - 막히면 여기서 질문하세요!

## 🎯 이 챕터의 목표

이 챕터를 완료하면:
- Web3와 블록체인이 무엇인지 이해할 수 있습니다
- 암호화폐 지갑(MetaMask) 설정할 수 있습니다
- Claude의 도움으로 지갑을 웹 앱에 연결할 수 있습니다!
- 테스트넷에서 첫 온체인 트랜잭션을 만들 수 있습니다
- Web3 전용 바이브코딩 팁과 주의사항을 배웁니다

## ⏱️ 예상 소요 시간
**2-3시간**

## 📋 필요한 것
- Chapter 20까지 완료 (풀스택 앱)
- Chrome/Brave 브라우저
- 실제 암호화폐 불필요 (테스트넷 사용)

## 🗺️ Web3 학습 여정 (Part 6)

```
┌─────────────────────────────────────────────────────────────┐
│                    Web3 학습 경로                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Chapter 28 (지금 여기) - "Web3 소비자"                        │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 🎯 목표: 사용자 관점에서 Web3 이해하기                   │   │
│  │ • 지갑 설정, 트랜잭션 이해                              │   │
│  │ • dapp 연결, 토큰/NFT 클레임                          │   │
│  │ • 지갑 연결하는 간단한 dapp 만들기                      │   │
│  │                                                      │   │
│  │ 📚 배울 것: 지갑, 가스, 테스트넷, IPFS                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                        ↓                                    │
│  Chapter 29 - "소셜 Web3 빌더"                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 🎯 목표: 인터랙티브 Web3 소셜 경험 만들기               │   │
│  │ • Ch28의 지갑 연결 활용                               │   │
│  │ • Farcaster Frames 만들기 (투표, 퀴즈, 민팅)           │   │
│  │ • 소셜 포스트에 온체인 액션 추가                        │   │
│  │                                                      │   │
│  │ 📚 배울 것: Frames API, 소셜 미니앱                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                        ↓                                    │
│  Chapter 30 - "스마트 컨트랙트 크리에이터"                      │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 🎯 목표: 나만의 스마트 컨트랙트 만들기                   │   │
│  │ • Claude와 함께 Solidity 코드 작성!                   │   │
│  │ • Base에 컨트랙트 배포                                │   │
│  │ • 최종 프로젝트: NFT 기반 커뮤니티                      │   │
│  │                                                      │   │
│  │ 📚 배울 것: Solidity, 배포, 보안                       │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  🎓 Part 6 완료 후: 풀스택 Web3 개발자!                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 스킬 진행

| 챕터 | 역할 | 만들 것 | 핵심 스킬 |
|------|------|---------|-----------|
| **28** | 소비자 | 지갑 앱, 클레임 사이트 | 지갑, 트랜잭션, IPFS |
| **29** | 빌더 | 인터랙티브 Frames | 소셜 Web3, Frames API |
| **30** | 크리에이터 | 스마트 컨트랙트, NFT 커뮤니티 | Solidity, 배포 |

> 💡 **학습 흐름**: Ch28에서 배우는 지갑 연결과 트랜잭션 스킬은 Ch29와 Ch30에서 계속 사용됩니다. 각 챕터는 이전 챕터의 지식을 기반으로 합니다.

---

## ⚠️ Web3 바이브코딩: 중요 경고

시작하기 전에, 일반 바이브코딩과 Web3 바이브코딩의 **중요한 차이점**이 있습니다:

### Web3에서 특별히 조심해야 하는 이유

| 일반 앱 | Web3 앱 |
|---------|---------|
| 버그 = 고치고 재배포 | 스마트 컨트랙트 버그 = **영구적** |
| 사용자 데이터 손실 = 백업에서 복원 | 사용자 암호화폐 손실 = **영원히 사라짐** |
| 보안 침해 = 비밀번호 재설정 | 보안 침해 = **자금 유출** |
| 가짜 데이터로 테스트 | **실제 테스트넷**에서 먼저 테스트 |

> 🚨 **중요 규칙**: Claude가 생성한 스마트 컨트랙트를 전문가 감사 없이 실제 돈과 함께 배포하지 마세요.

### Web3 바이브코딩 황금 규칙

1. **항상 테스트넷 먼저** - 실제 암호화폐로 테스트하지 마세요
2. **주소 두 번 확인** - 한 글자 잘못 = 자금 손실
3. **서명 전에 이해하기** - Claude에게 무엇을 승인하는지 설명 요청하세요
4. **개인 키 공유 금지** - Claude 채팅에서도 공유하지 마세요
5. **소액부터 시작** - 메인넷에서도 아주 작은 금액으로 테스트하세요

```
You: Web3 개발에서 가장 큰 보안 실수는 뭐야?

Claude: 피해야 할 중요한 것들:
        1. 코드/git에 개인 키 노출
        2. 스마트 컨트랙트에서 사용자 입력 검증 안 함
        3. 테스트 안 된 라이브러리 사용
        4. 테스트넷 완전히 건너뛰기
        5. 무제한 토큰 지출 승인
```

---

## Web3란 무엇인가?

### 웹의 진화

이렇게 생각해보세요 - 인터넷이 성장했습니다:

```
Web1 (1990년대): 읽기 전용 📰
└── 도서관 같은 것 - 읽기만 가능
└── 정적 웹사이트, 콘텐츠만 소비
└── 예: 뉴스 사이트, 위키피디아
└── "보기만 하고 건드리지 마세요!"

Web2 (2000년대-현재): 읽기-쓰기 📱
└── 쇼핑몰 같은 것 - 사고 팔 수 있음
└── 소셜 미디어, 콘텐츠 생성
└── 하지만 몰이 모든 걸 소유 (게시물, 팔로워, 데이터)
└── 예: Facebook, YouTube, Twitter
└── "우리 놀이터에서 놀아도 되지만, 규칙은 우리가 만들어"

Web3 (등장 중): 읽기-쓰기-소유 🔑
└── 자기 집을 소유하는 것 - 실제로 당신 것
└── 블록체인 기반, 데이터와 자산을 소유
└── 쫓아낼 수 있는 집주인 없음
└── 예: DeFi, NFT, DAO
└── "내 키, 내 코인, 내 규칙"
```

> 💡 **진짜 이야기**: 인스타그램이 게시물을 삭제한 적 있나요? 스포티파이가 플레이리스트를 지운 적은요? Web3에서는 그런 일이 일어날 수 없습니다. 아파트 임대와 자기 집 소유의 차이와 같습니다.

### 핵심 개념

| 용어 | 간단한 설명 | 실제 비유 |
|------|-------------|-----------|
| **블록체인** | 아무도 통제하지 않는 공유 데이터베이스 | 모두가 볼 수 있지만 기록 삭제는 불가능한 구글 문서 |
| **지갑** | 당신의 신원 + 은행 계좌 | 여권 + 은행 계좌가 하나의 앱에 |
| **트랜잭션** | 블록체인에서의 모든 행동 | 공유 구글 문서에 항목 추가하기 |
| **가스** | 블록체인 사용 수수료 | 우표 - 항목을 보내려면 비용 지불 |
| **테스트넷** | 연습용 블록체인 (무료!) | 모노폴리 머니 - 진짜처럼 보이지만 가치 없음 |
| **메인넷** | 실제 블록체인 (실제 돈) | 실제 은행 계좌 - 조심하세요! |
| **스마트 컨트랙트** | 블록체인에서 실행되는 코드 | 아무도 해킹할 수 없는 자판기 |
| **ABI** | 컨트랙트의 사용 설명서 | 자판기 "사용법" 가이드 |

> 💡 **초보자 팁**: 블록체인을 공개 노트북이라고 상상해보세요:
> - 누구나 읽을 수 있음
> - 누구나 쓸 수 있음 ("잉크 비용"을 내면)
> - 한번 쓰면 절대 지울 수 없음
> - 아무도 노트북을 소유하지 않음

### "커피숍" 비유로 모든 것 이해하기

```
커피숍으로 Web3를 이해하기 위한 멘탈 모델을 만들어봅시다:

☕ 지갑 = 커피숍 멤버십 앱
   - 당신의 ID가 있음 (공개 주소)
   - 비밀 PIN이 있음 (개인 키)
   - 리워드 포인트 표시 (토큰 잔액)

💰 트랜잭션 = 커피 주문하기
   - 앱을 탭함 (지갑으로 서명)
   - 주문 비용 지불 (가스 수수료)
   - 영수증 받기 (트랜잭션 해시)
   - 영수증은 영원히 저장됨 (블록체인에)

📜 스마트 컨트랙트 = 커피 머신
   - 같은 입력은 항상 = 같은 출력
   - 아무도 속일 수 없음 (가게 주인도)
   - 규칙이 모두에게 보임
   - "5천원 넣기 → 커피 받기" 항상 작동

🎨 NFT = 한정판 커피 머그
   - 오직 당신만 이 특정 머그 소유
   - 번호 매겨짐 (Token ID #42)
   - 소유 증명 가능
   - 팔거나 교환 가능
```

### 왜 Base인가?

이 커리큘럼에서는 **Base** 블록체인을 사용합니다:

| 특징 | Base | 중요한 이유 |
|------|------|-------------|
| **만든 곳** | Coinbase | 신뢰할 수 있고, 자금력 있음 |
| **타입** | Layer 2 (L2) | 이더리움 메인넷보다 빠르고 저렴 |
| **속도** | ~2초 블록 | 개발할 때 빠른 피드백 |
| **비용** | 매우 낮은 수수료 | 테스트넷 ETH가 바닥나지 않음 |
| **보안** | 이더리움이 보안 담당 | 이더리움의 보안을 상속 |
| **생태계** | 빠르게 성장 중 | 예제/도움 찾기 좋음 |

---

## Step 1: MetaMask 지갑 설정

### 1.1 MetaMask 설치

```
You: MetaMask 브라우저 확장 프로그램 설치 도와줘. 단계별로 안내해줘.

Claude: MetaMask 설치를 안내해드릴게요...
        1. metamask.io로 이동
        2. Download 클릭
        3. 브라우저 선택 (Chrome 권장)
        4. 확장 프로그램 추가
        5. "Create a new wallet" 클릭
        6. 강력한 비밀번호 생성
        7. 중요: 시크릿 복구 구문을 종이에 적어두세요
```

### 1.2 지갑 이해하기

```
You: MetaMask를 5살에게 설명하듯 설명해줘

Claude: MetaMask 지갑은 마법의 열쇠고리 같아요:
        - "주소" (0x...)는 우편함 번호 - 누구나 물건을 보낼 수 있어요
        - "개인 키"는 집 열쇠 - 절대 공유하면 안 돼요
        - "복구 구문"은 바위 밑에 숨긴 여분의 열쇠 - 아주 안전하게 보관하세요
        - "네트워크"는 다른 우체국 같아요 - 일부는 연습용 (테스트넷)
```

### 1.3 보안 필수 사항

> ⚠️ **중요 보안 - 주의 깊게 읽으세요**

**시크릿 복구 구문:**
- 지갑을 복구하는 유일한 방법
- **종이**에 적어야 함 (디지털 아님)
- **안전한 장소**에 보관
- 누구와도 **절대 공유하지 마세요**
- "지원팀"이라며 요청해도 안 됨 (사기꾼입니다)

```
You: 시크릿 복구 구문이 뭐고 왜 그렇게 중요해?

Claude: 시크릿 복구 구문(시드 구문)은 12-24개의 단어예요:
        "사과 바나나 고양이 개 코끼리 물고기..."

        이 단어들을 가진 사람은:
        - 당신의 모든 자금에 접근 가능
        - 모든 것을 자기 지갑으로 전송 가능
        - 그리고 절대 되찾을 수 없음

        암호화폐에는 "비밀번호 찾기"가 없어요.
        구문을 잃으면 = 모든 것을 잃는 거예요.
```

**피해야 할 흔한 사기:**

| 사기 유형 | 작동 방식 | 피하는 방법 |
|-----------|-----------|-------------|
| 가짜 지원팀 | "도움을 위해 시드 구문이 필요합니다" | 진짜 지원팀은 시드를 절대 요청 안 함 |
| 피싱 사이트 | metamask.com (가짜) vs metamask.io (진짜) | 항상 URL 확인 |
| 악성 토큰 | 팔려고 하면 지갑을 비우는 에어드롭 토큰 | 모르는 토큰과 상호작용 금지 |
| Discord DM | "당첨! 이 링크 클릭" | 서버에서 DM 비활성화 |

### 1.4 Base Sepolia 테스트넷 추가

```
You: MetaMask에 Base Sepolia 테스트넷 추가하는 거 도와줘

Claude: Base Sepolia용 MetaMask 설정을 도와드릴게요.

        방법 1 (자동):
        chainlist.org 가서, "Base Sepolia" 검색, "Add to MetaMask" 클릭

        방법 2 (수동):
        설정 → 네트워크 → 네트워크 추가:
        - 네트워크 이름: Base Sepolia
        - RPC URL: https://sepolia.base.org
        - 체인 ID: 84532
        - 통화 기호: ETH
        - 블록 탐색기: https://sepolia.basescan.org
```

### 1.5 설정 확인하기

```
You: MetaMask가 제대로 설정됐는지 어떻게 확인해?

Claude: 확인해봅시다:
        1. MetaMask 확장 프로그램 클릭
        2. 상단에 "Base Sepolia"가 보여야 함 ("Ethereum Mainnet" 아님)
        3. 주소가 0x로 시작하고 42자여야 함
        4. 잔액이 0 ETH로 표시됨 (다음에 테스트 ETH 받을 예정)
```

---

## Step 2: 테스트넷 ETH 받기

### 2.1 Faucet이란?

```
You: Web3에서 faucet이 뭐야?

Claude: Faucet은 무료 테스트 암호화폐를 주는 웹사이트예요.
        소량의 테스트 토큰을 "뚝뚝 떨어뜨리기" 때문에 "faucet(수도꼭지)"이라고 불러요.

        존재 이유:
        - 개발자들이 앱을 만들려면 테스트 ETH가 필요
        - 테스트 ETH는 실제 가치가 없음
        - 실제 돈을 사용하기 전에 모두가 연습하는 방법
```

### 2.2 테스트 ETH 받기

```
You: Base Sepolia용 테스트넷 ETH 받는 거 도와줘

Claude: 시도할 수 있는 faucet들:

        1. Alchemy Faucet (https://www.alchemy.com/faucets/base-sepolia)
           - Alchemy 계정 필요 (무료)
           - 하루에 0.1 ETH 제공

        2. Coinbase Faucet (https://portal.cdp.coinbase.com/products/faucet)
           - Coinbase 개발자 계정 필요
           - 괜찮은 양의 테스트 ETH

        3. QuickNode Faucet (https://faucet.quicknode.com/base/sepolia)
           - 소셜 인증이 필요할 수 있음

        어떤 걸 시도하는지 알려주시면 도와드릴게요.
```

> 💡 **팁**: Faucet에는 종종 요구사항이 있어요:
> - 소셜 미디어 인증
> - 요청 사이 대기 시간
> - 메인넷에 소량의 ETH
> 하나가 안 되면, 다른 걸 시도하세요!

### 2.3 잔액 확인하기

```
You: 테스트넷 ETH를 받았는지 어떻게 확인해?

Claude: MetaMask에서 확인:
        1. MetaMask 열기
        2. 상단에 "Base Sepolia" 선택 확인
        3. 잔액이 "0.1 ETH" 같이 표시되어야 함

        또는 블록 탐색기에서 확인:
        1. sepolia.basescan.org 가기
        2. 지갑 주소 붙여넣기
        3. 잔액과 트랜잭션 내역 확인
```

---

## Step 3: 지갑 연결 앱 만들기

MetaMask에 연결하는 간단한 웹 앱을 만들어봅시다 - **바이브코딩으로**!

### 3.1 프로젝트 이해하기

```
You: 우리가 뭘 만드는지, 왜 만드는지 설명해줘

Claude: "dapp" (탈중앙화 앱)을 만들 거예요:
        1. "Connect Wallet" 버튼 표시
        2. 클릭하면 MetaMask 열림
        3. 연결 후 주소 표시
        4. ETH 잔액 표시
        5. 다른 주소로 ETH 보내기

        이게 모든 Web3 앱의 기초예요!
```

### 3.2 프로젝트 생성

```
You: Web3 지갑 연결이 있는 Next.js 프로젝트 만들어줘.
     wagmi와 viem 사용해 (최신 표준이래).
     Base Sepolia 테스트넷용으로 설정해줘.

Claude: 베스트 프랙티스로 프로젝트를 만들게요...
        [프로젝트 구조 생성]
        [wagmi, viem, @tanstack/react-query 설치]
        [providers와 config 설정]
        [WalletButton 컴포넌트 생성]
```

> 💡 **바이브코딩 팁**: wagmi, viem, 또는 어떤 Web3 라이브러리 문법도 알 필요 없어요. 원하는 걸 설명하면 Claude가 코드를 작성해줍니다!

### 3.3 Web3 라이브러리 선택

```
You: 왜 ethers.js나 web3.js 대신 wagmi와 viem이야?

Claude: 좋은 질문이에요! 여기 현황이에요:

        | 라이브러리 | 장점 | 단점 |
        |-----------|------|------|
        | wagmi + viem | 최신, React hooks, TypeScript | 더 새로움, 레거시 문서 적음 |
        | ethers.js v6 | 인기 있음, 좋은 문서 | 더 무거움, React 네이티브 아님 |
        | web3.js | OG 라이브러리, 많은 예제 | 오래된 패턴, 더 큰 번들 |

        2024년 이후 React 앱에서는 wagmi + viem이 권장이에요.
        하지만 개념은 어떤 라이브러리에도 적용돼요!
```

### 3.4 지갑 연결 추가

```
You: 클릭하면 MetaMask에 연결하는 버튼 추가해줘,
     연결된 주소를 보여주고, 연결 해제 버튼도 있게

Claude: WalletConnect 컴포넌트를 만들게요...
        [wagmi hooks를 사용해 컴포넌트 작성]
```

### 3.5 코드 이해하기

> 💡 **바이브코딩 + 이해**: Claude가 코드를 작성해도, 설명을 요청하세요! 문법을 외우지 않더라도 무엇이 일어나는지 이해해야 해요.

```
You: 방금 작성한 코드가 뭘 하는지 설명해줘.
     특히 useAccount, useConnect, useDisconnect.

Claude: 분석해볼게요:

        useAccount():
        - "누가 로그인했어?"라고 묻는 것
        - { address, isConnected }를 반환
        - address는 사용자의 지갑 (0x...)
        - isConnected는 true/false

        useConnect():
        - "로그인" 플로우를 트리거
        - MetaMask 팝업 열기
        - 사용자 승인 대기

        useDisconnect():
        - 사용자 로그아웃
        - 연결 해제

        흐름:
        1. 사용자가 "Connect" 클릭
        2. MetaMask 팝업 열림
        3. 사용자가 승인
        4. useAccount가 이제 그들의 주소를 가짐
        5. UI가 주소를 보여주도록 업데이트
```

### 3.6 실행하고 테스트

```
You: 앱을 실행하고 지갑 연결 테스트 도와줘

Claude: 개발 서버 시작 중...
        npm run dev

        이제:
        1. http://localhost:3000 열기
        2. "Connect Wallet" 클릭
        3. MetaMask 팝업이 나타나야 함
        4. MetaMask에서 "Connect" 클릭
        5. 페이지에 주소가 표시되어야 함!
```

---

## Step 4: 블록체인 데이터 읽기

### 4.1 ETH 잔액 표시

```
You: 연결된 지갑의 ETH 잔액을 보여주는 컴포넌트 추가해줘.
     잔액이 변경되면 자동으로 업데이트되게.

Claude: wagmi의 useBalance hook을 사용할게요...
        [잔액 표시 컴포넌트 작성]

        이렇게 될 거예요:
        - ETH로 잔액 표시 (wei 아님)
        - 5초마다 자동 업데이트
        - 가져오는 동안 로딩 상태 표시
```

### 4.2 Wei vs ETH 이해하기

```
You: "wei"가 뭐고 왜 Web3 코드에서 계속 보여?

Claude: ETH는 18자리 소수점을 가지는데, 컴퓨터가 정확하게 다루기엔 너무 많아요.

        그래서 내부적으로 모든 건 "wei" (가장 작은 단위)로 저장돼요:
        - 1 ETH = 1,000,000,000,000,000,000 wei (0이 18개)
        - 1달러 = 100센트와 비슷하지만, 소수점이 훨씬 많음

        일반적인 변환:
        - 1 ETH = 10^18 wei
        - 1 gwei = 10^9 wei (가스 가격에 사용)
        - 0.001 ETH = 10^15 wei

        라이브러리가 이걸 처리해줘요:
        - parseEther("1.5") → "1.5 ETH"를 wei로 변환
        - formatEther(wei) → wei를 읽을 수 있는 ETH로 변환
```

### 4.3 현재 블록 표시

```
You: 현재 블록 넘버도 보여줘.
     블록 넘버가 뭔지 설명해줘.

Claude: 블록 넘버 표시 추가 중...

        블록 넘버는 블록체인 역사책의 페이지 번호 같아요:
        - Base에서 약 2초마다 새 "페이지" (블록)가 추가됨
        - 각 블록에는 그 순간의 트랜잭션이 포함
        - 블록 1000은 블록 2000보다 먼저 발생
        - 용도: 언제 일어났는지 추적, 액션 조정
```

### 4.4 컨트랙트 데이터 읽기 (미리보기)

```
You: 아무 스마트 컨트랙트에서 데이터를 읽을 수 있어?

Claude: 네! 필요한 것:
        1. 컨트랙트 주소 (어디에 있는지)
        2. ABI (어떤 함수가 있는지)

        예시 - ERC20 토큰 잔액 읽기:
        [useReadContract hook 예시 보여주기]

        이건 Chapter 30에서 더 할 거예요!
```

---

## Step 5: 트랜잭션 보내기

### 5.1 트랜잭션 이해하기

```
You: 블록체인에서 ETH를 보낼 때 무슨 일이 일어나는지 설명해줘

Claude: 전체 여정이에요:

        1. 당신: "Send" 클릭
        2. 당신의 앱: 트랜잭션 데이터 생성
        3. METAMASK: 무엇을 승인하는지 보여줌
        4. 당신: "Confirm" 클릭 (또는 거부)
        5. METAMASK: 개인 키로 서명
        6. 네트워크: 블록체인 노드에 브로드캐스트
        7. 채굴자/검증자: 다음 블록에 포함
        8. 블록체인: 트랜잭션이 이제 영구적!

        중요한 개념:
        - 가스: 검증자에게 지불하는 수수료 (네트워크 혼잡에 따라 변동)
        - Nonce: 트랜잭션 카운터 (재전송 공격 방지)
        - 해시: 트랜잭션의 고유 ID (발생 증거)
```

### 5.2 보내기 폼 추가

```
You: ETH를 보낼 주소와 금액을 입력할 수 있는 폼 추가해줘.
     주소가 유효한지 확인하는 유효성 검사 포함.
     보내기 전에 가스 예상치도 보여줘.

Claude: 유효성 검사가 있는 보내기 폼을 만들게요...
        [SendETH 컴포넌트 생성]

        포함된 것:
        - 주소 유효성 검사 (유효한 이더리움 주소여야 함)
        - 금액 유효성 검사 (잔액보다 많이 보낼 수 없음)
        - 가스 예상치 (대략적인 비용 표시)
        - 트랜잭션 상태 (대기 중, 성공, 실패)
```

### 5.3 트랜잭션 테스트

```
You: 폼을 테스트하기 위해 0.001 ETH 보내는 거 도와줘

Claude: 테스트 트랜잭션을 해봅시다:

        1. "To Address"에 입력할 수 있는 것:
           - 당신이 소유한 다른 지갑, 또는
           - 0x000...dead 같은 "burn" 주소 (테스트용)

        2. 금액 필드에 0.001 입력

        3. "Send" 클릭 - MetaMask가 팝업됨

        4. MetaMask에서 세부사항 확인:
           - 보낼 곳: [정확한 주소?]
           - 금액: 0.001 ETH
           - 가스 수수료: ~$0.01 이하

        5. "Confirm" 클릭

        6. 확인 대기 (Base에서 보통 ~2초)

        7. 트랜잭션 해시를 받을 거예요 - 저장하세요!
```

### 5.4 탐색기에서 트랜잭션 보기

```
You: 트랜잭션 세부사항을 어떻게 봐?

Claude: 블록 탐색기로 가세요:
        1. https://sepolia.basescan.org 열기
        2. 트랜잭션 해시 붙여넣기 (0x...)
        3. 볼 수 있는 것:
           - 상태: 성공/실패
           - 블록: 어떤 블록에 포함됐는지
           - From/To: 관련된 주소
           - 값: 얼마가 전송됐는지
           - 가스: 얼마를 지불했는지

        또는 앱에서 해시를 클릭 - 링크로 만들 수 있어요!
```

---

## Step 6: Web3 바이브코딩 베스트 프랙티스

### 6.1 Web3용 프롬프팅 팁

```
You: Web3 코드를 위해 Claude에게 어떻게 프롬프트해야 해?

Claude: Web3 프롬프팅 팁:

        명확하게 지정할 것:
        1. 어떤 체인 (Base, Ethereum, Polygon?)
        2. 테스트넷인지 메인넷인지
        3. 어떤 라이브러리 (wagmi, ethers, web3.js?)
        4. React인지 vanilla JS인지

        항상 언급할 것:
        - "TypeScript 사용해"
        - "에러 제대로 처리해"
        - "로딩 상태 보여줘"
        - "테스트넷에서 먼저 작동하게 해"

        좋은 프롬프트:
        "wagmi를 사용해서 Base Sepolia에서 ERC20 토큰 잔액을 읽는
         컴포넌트 만들어줘. 로딩과 에러 상태 보여줘.
         TypeScript 사용하고 지갑이 연결 안 된 경우도 처리해."

        나쁜 프롬프트:
        "토큰 잔액 보여줘"
```

### 6.2 테스트 전략

```
You: Web3 코드를 테스트하는 올바른 방법은?

Claude: Web3 테스트 피라미드:

        레벨 1: 로컬 테스트
        - hardhat/foundry 로컬 노드 사용
        - 즉각적, 무료, 시간 여행 가능

        레벨 2: 테스트넷 테스트 (Base Sepolia)
        - 실제 네트워크 동작
        - 무료 테스트 토큰
        - 통합 테스트에 좋음

        레벨 3: 메인넷 테스트
        - 철저한 테스트넷 테스트 후에만
        - 아주 작은 금액으로 시작
        - 복구 계획 준비

        바이브코딩을 위해:
        "매번 테스트넷 ETH 사용하지 않고 테스트할 수 있도록
         Hardhat으로 로컬 테스트 설정하는 거 도와줘"
```

### 6.3 흔한 함정

```
You: Web3 개발에서 초보자들이 하는 실수는?

Claude: Web3 초보자 실수 Top:

        1. 잘못된 네트워크
           - 테스트넷이 아닌 메인넷에 보내기
           - 해결: 확인 전에 항상 MetaMask에서 네트워크 확인

        2. 잘못된 주소 형식
           - 잘못된 체인 주소 사용 (Bitcoin에 ETH 주소)
           - 해결: 항상 체크섬된 주소 사용

        3. 거부 처리 안 함
           - 사용자가 MetaMask 취소 = 처리되지 않은 에러
           - 해결: 항상 사용자 거부 catch

        4. AI가 생성한 컨트랙트 코드 신뢰
           - Claude가 Solidity를 쓸 수 있지만, 보안 버그 = 자금 손실
           - 해결: 실제 돈이 있는 것은 항상 전문가 감사 받기

        5. 코드에 개인 키 저장
           - git에 커밋된 .env 파일 = 해킹된 지갑
           - 해결: 하드웨어 지갑 사용, 키 하드코딩 금지

        6. 가스 이해 부족
           - 가스가 너무 낮아서 트랜잭션 멈춤
           - 해결: 가스 가격 vs 가스 리밋 배우기
```

---

## Step 7: 토큰/NFT 클레임 사이트 만들기

흥미로운 걸 만들어봅시다 - 사용자가 폼을 작성하고 **토큰이나 NFT**를 지갑으로 직접 받는 웹사이트!

### 7.1 프로젝트 개요

```
You: 이런 사이트를 만들고 싶어:
     1. 사용자가 지갑 연결
     2. 사용자가 폼 작성 (이름, 이메일, 이미지 업로드)
     3. 사용자가 "Claim" 클릭
     4. 토큰 또는 NFT를 받음 (이미지로 만든)

     Base Sepolia에서 이거 만들 수 있어?

Claude: 물론이죠! 이건 "클레임" 또는 "에어드롭" 플로우라고 해요.

        작동하려면 필요한 것:
        1. 프론트엔드: 폼 + 지갑 연결
        2. 백엔드: 민팅을 트리거하는 API
        3. 스마트 컨트랙트: 민팅할 수 있는 배포된 컨트랙트
        4. 스토리지: NFT 이미지용 IPFS

        단계별로 만들어봅시다!
```

### 7.2 토큰 vs NFT 이해하기

```
You: 처음 접하는 사람에게 토큰과 NFT의 차이를 설명해줘

Claude: 이렇게 생각해보세요:

        토큰 (ERC20):
        - 코인이나 포인트 같은 것
        - 모든 토큰이 동일 (1 TOKEN = 1 TOKEN)
        - 나눌 수 있음 (0.5 토큰 가질 수 있음)
        - 예: USDC, DEGEN, 게임 포인트

        NFT (ERC721):
        - 트레이딩 카드나 아트 같은 것
        - 모든 NFT가 고유 (NFT #1 ≠ NFT #2)
        - 나눌 수 없음 (NFT 반 개 가질 수 없음)
        - 예: 아트, PFP, 티켓, 인증서

        우리 프로젝트에서:
        - 토큰 클레임 = 사용자에게 100 REWARD 토큰 제공
        - NFT 클레임 = 업로드한 이미지로 고유 NFT 민팅
```

### 7.3 옵션 A: 토큰 클레임 사이트 만들기

```
You: 간단한 토큰 클레임부터 시작하자.
     이런 사이트를 만들어줘:
     1. 사용자가 지갑 연결
     2. 사용자가 이름과 이메일 입력
     3. 사용자가 "Claim 100 REWARD tokens" 클릭
     4. 토큰이 지갑으로 전송됨

Claude: 이 프로젝트를 설정할게요.

        민팅을 허용하는 Base Sepolia에 배포된 ERC20 컨트랙트를 사용할 거예요.
        계획은 이래요:

        1. 폼 UI 생성
        2. 토큰 컨트랙트에 연결
        3. 사용자가 클레임할 때 mint 함수 호출
        4. 트랜잭션 링크와 함께 성공 표시
```

#### 토큰 컨트랙트 설정

```
You: 민팅할 수 있는 토큰 컨트랙트를 어떻게 얻어?

Claude: 학습 목적으로, 옵션이 있어요:

        옵션 1: 기존 테스트 토큰 사용
        - 많은 테스트 토큰이 무료 민팅 허용
        - 학습에 좋고, 설정 필요 없음

        옵션 2: 직접 배포 (Chapter 30 미리보기)
        - mint 함수가 있는 간단한 ERC20 생성
        - 모든 걸 직접 통제

        지금은 Zora 테스트넷의 연습용 토큰을 사용하거나,
        Remix IDE를 사용해서 간단한 걸 배포하는 걸 도와드릴게요.
```

#### 클레임 폼 만들기

```
You: 토큰 클레임 폼 만들어줘:
     - 이름 필드
     - 이메일 필드 (지금은 로컬에 저장만)
     - 클레임 버튼
     - 대기 중/성공 상태 표시

Claude: ClaimToken 컴포넌트를 만들게요...
        [유효성 검사가 있는 폼 생성]
        [지갑 연결 확인 추가]
        [컨트랙트 상호작용 추가]
        [트랜잭션 상태 표시]
```

### 7.4 옵션 B: NFT 민팅 사이트 만들기 (사용자 이미지로!)

이게 더 흥미로워요 - 사용자가 이미지를 업로드하면 고유 NFT가 됩니다!

```
You: 이제 NFT 버전을 해보자.
     사용자가 이미지를 업로드하면 지갑으로 NFT로 민팅해.
     어떻게 작동하는지 설명해줘.

Claude: 좋아요! NFT 민팅 플로우예요:

        1. 사용자가 이미지 업로드
        2. 이미지 → IPFS (탈중앙화 스토리지)
        3. 메타데이터 (이름, 설명, 이미지 URL) → IPFS
        4. 메타데이터 URL로 NFT 민팅 → 블록체인
        5. 사용자가 이제 NFT 소유!

        필요한 것:
        - IPFS 업로드 (NFT.Storage나 Pinata 사용)
        - 민팅을 허용하는 NFT 컨트랙트
        - 프론트엔드 폼
```

#### IPFS 이해하기

```
You: IPFS가 뭐고 왜 NFT에 필요해?

Claude: IPFS = InterPlanetary File System (행성간 파일 시스템)

        문제점:
        - 블록체인은 비쌈 (1MB 저장 = 많은 $$$)
        - 이미지는 큼 (100KB에서 몇 MB)
        - 일반 서버에 저장하면, 서버 죽으면 = 이미지 사라짐

        해결책 (IPFS):
        - 탈중앙화 파일 스토리지
        - 파일이 고유 "해시"를 주소로 가짐
        - 누구나 파일을 호스팅 가능
        - 한 명이라도 가지고 있으면, 존재함

        블록체인의 NFT 저장: "ipfs://Qm123abc..."
        IPFS가 그 주소에 실제 이미지를 가지고 있어요!
```

#### IPFS 업로드 설정

```
You: NFT 이미지용 IPFS 업로드 설정해줘.
     설정하기 쉬운 무료 서비스 사용해.

Claude: NFT.Storage 추천해요 (무료, Protocol Labs 운영):

        1. nft.storage 가기
        2. 무료 계정 생성
        3. API 키 받기
        4. .env.local에 추가

        업로드 함수를 만들게요:
        - 사용자의 이미지 파일 받기
        - NFT.Storage를 통해 IPFS에 업로드
        - IPFS URL 반환 (ipfs://...)
```

#### NFT 민팅 폼 만들기

```
You: NFT 민팅 폼 만들어줘:
     - 미리보기가 있는 이미지 업로드
     - NFT 이름 필드
     - 설명 필드
     - 민팅 버튼
     - 마지막에 민팅된 NFT 표시

Claude: MintNFT 컴포넌트를 만들게요...
        [드래그 앤 드롭 이미지 업로드 생성]
        [이미지 미리보기 추가]
        [이름/설명 필드 추가]
        [IPFS 업로드 처리]
        [NFT 컨트랙트 mint 호출]
        [OpenSea 링크와 함께 민팅된 NFT 표시]
```

### 7.5 완전한 NFT 민팅 플로우

전체 사용자 경험이에요:

```
┌─────────────────────────────────────────────────────────────┐
│                     NFT 민팅 플로우                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Step 1: 지갑 연결                                           │
│  [Connect Wallet 버튼]                                      │
│                                                             │
│  Step 2: 이미지 업로드                                       │
│  ┌─────────────────────┐                                    │
│  │  드래그 앤 드롭      │  ← 사용자 이미지가 NFT가 됨         │
│  │  또는 클릭해서 업로드 │                                    │
│  └─────────────────────┘                                    │
│                                                             │
│  Step 3: 세부사항 추가                                       │
│  이름: [My Awesome NFT_______]                              │
│  설명: [내 첫 번째 NFT!_]                                    │
│                                                             │
│  Step 4: 민팅!                                              │
│  [🎨 Mint NFT] ← IPFS 업로드 + 블록체인 민팅 트리거          │
│                                                             │
│  Step 5: 성공!                                              │
│  ┌─────────────────────┐                                    │
│  │   [NFT 이미지]       │                                    │
│  │   My Awesome NFT    │                                    │
│  │   Token ID: #42     │                                    │
│  │   [OpenSea에서 보기] │                                    │
│  └─────────────────────┘                                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 7.6 중요한 고려사항

```
You: 실제 사용자에게 배포하기 전에 알아야 할 것은?

Claude: 프로덕션을 위한 중요 포인트:

        1. 가스 비용
           - 민팅은 가스가 들어요
           - 옵션 A: 사용자가 지불 (ETH 필요)
           - 옵션 B: 당신이 지불 (가스리스/스폰서 민팅)

        2. 스팸 방지
           - 누구나 민팅 가능 = 누군가 남용할 것
           - 레이트 리미팅, 캡차, 또는 허용 목록 추가

        3. 이미지 크기 제한
           - 큰 이미지 = 느린 업로드
           - 최대 파일 크기 추가 (예: 5MB)

        4. 컨트랙트 소유권
           - 누가 컨트랙트를 소유하나?
           - 문제가 생기면 일시 정지 가능?

        5. IPFS 피닝
           - 무료 티어에는 제한이 있음
           - 프로덕션용으로는 유료 피닝이나 Arweave 사용

        테스트넷 학습용으로는 아직 이것들 걱정 안 해도 돼요!
```

### 7.7 민팅 사이트 테스트

```
You: 완전한 민팅 플로우 테스트 도와줘

Claude: 단계별로 테스트해봅시다:

        1. 앱 시작: npm run dev

        2. http://localhost:3000 열기

        3. 지갑 연결 (Base Sepolia!)

        4. 테스트 이미지 업로드 (아무 사진이나)

        5. 이름 입력: "My First NFT"

        6. 설명 입력: "바이브코딩으로 민팅!"

        7. "Mint NFT" 클릭

        8. 진행 상황 확인:
           - "IPFS에 업로드 중..." (몇 초)
           - "NFT 민팅 중..." (MetaMask 팝업)
           - "MetaMask에서 확인"
           - "확인 대기 중..."
           - "성공! NFT #X 민팅됨!"

        9. OpenSea 테스트넷 링크를 클릭해서 확인!
```

---

## 🔨 연습: 완전한 Dapp

Claude에게 이 기능들을 추가하도록 요청해서 완전한 dapp을 만들어보세요:

```
You: 이런 완전한 dapp 만드는 거 도와줘:
     1. 연결 상태가 있는 지갑 연결/해제 버튼
     2. 연결된 주소 표시 (축약 형식)
     3. 10초마다 업데이트되는 ETH 잔액 표시
     4. ETH 보내기 폼:
        - 주소 유효성 검사
        - 금액 유효성 검사 (잔액 초과 불가)
        - 가스 예상치
        - 트랜잭션 상태 추적
     5. 트랜잭션 히스토리 (이 세션의 최근 5개 트랜잭션)
     6. 모든 엣지 케이스 에러 처리
     7. 모든 비동기 작업의 로딩 상태

     wagmi, viem, TypeScript 사용해. Base Sepolia 타겟.

Claude: 단계별로 만들어봅시다...
        [모든 기능이 있는 완전한 dapp 생성]
```

> 💡 **바이브코딩 접근법**: 위 프롬프트로 시작하고, 다듬어나가세요. "연결 버튼이 너무 작아." "주소 복사 버튼 추가해." "트랜잭션 히스토리에 타임스탬프 보여줘."

---

## ❌ 흔한 실수

| 실수 | Claude에게 물어볼 것 |
|------|---------------------|
| "MetaMask not detected" | "MetaMask가 연결 안 돼, 디버그 도와줘. 에러: [에러]" |
| 트랜잭션 멈춤 | "트랜잭션이 5분째 pending이야, 뭐가 잘못됐어?" |
| 잘못된 네트워크 | "메인넷인데 테스트넷이어야 해. 네트워크 전환 추가 도와줘." |
| "Insufficient funds" | "0.1 ETH 있는데 insufficient funds 에러가 나. 뭐가 잘못됐어?" |
| 가스 예상 실패 | "트랜잭션 가스 예상 실패. 에러: [에러]. 이게 무슨 뜻이야?" |
| 주소 유효하지 않음 | "주소 유효성 검사가 invalid라는데 맞아 보여. 디버그 도와줘." |

---

## 🆘 막힐 때

### Claude와 디버깅

```
You: [전체 에러 메시지 복사 붙여넣기]
     지갑 연결하려고 할 때 이 에러가 나타났어.
     Base Sepolia에서 wagmi v2 사용 중.

Claude: 이 에러는... 이렇게 고치면 돼...
```

> 💡 **디버깅 팁**: 항상 포함하세요:
> - 전체 에러 메시지
> - 뭘 하려고 했는지
> - 어떤 라이브러리/버전
> - 어떤 네트워크

### 개념 이해하기

```
You: "서명"과 트랜잭션 "보내기"의 차이가 계속 들려. 뭐가 달라?

Claude: 좋은 질문이에요!

        서명 (무료):
        - 개인 키를 사용해 당신임을 증명
        - 가스 안 듦
        - 용도: 로그인, 소유권 증명, 오프체인 액션
        - 예: Sign in with Ethereum

        보내기 (가스 듦):
        - 실제로 블록체인 상태를 변경
        - 가스 비용 (실제 수수료)
        - 용도: 전송, 컨트랙트 상호작용
        - 예: ETH 보내기, NFT 민팅

        둘 다 MetaMask 확인이 필요하지만, 보내기만 비용이 들어요!
```

---

## ✅ 체크리스트

넘어가기 전에 확인하세요:

- [ ] MetaMask 설치 및 보안 설정 완료
- [ ] 시드 구문 중요성 이해 (안전하게 보관)
- [ ] Base Sepolia 테스트넷 설정 완료
- [ ] faucet에서 테스트넷 ETH 받음
- [ ] Claude와 함께 지갑 연결 앱 만들기!
- [ ] 지갑 연결 및 해제 가능
- [ ] ETH 잔액 볼 수 있음
- [ ] 테스트 트랜잭션 성공적으로 전송
- [ ] 블록 탐색기에서 트랜잭션 확인
- [ ] Claude와 함께 토큰 또는 NFT 클레임 사이트 만들기!
- [ ] IPFS와 NFT가 왜 사용하는지 이해
- [ ] 내 이미지로 NFT 성공적으로 민팅
- [ ] Web3 바이브코딩 경고 이해
- [ ] 테스트넷과 메인넷의 차이 알기
- [ ] 기본 개념 이해 (지갑, 트랜잭션, 가스, wei, 토큰, NFT)

---

## 📖 더 배우기

### 공식 문서
- [MetaMask Docs](https://docs.metamask.io/)
- [Base Documentation](https://docs.base.org/)
- [wagmi Documentation](https://wagmi.sh/)
- [viem Documentation](https://viem.sh/)

### 보안 리소스
- [Smart Contract Security Best Practices](https://consensys.github.io/smart-contract-best-practices/)
- [Common Web3 Scams](https://www.youtube.com/results?search_query=web3+scam+awareness)

### 비디오
- [What is Web3?](https://www.youtube.com/results?search_query=what+is+web3+explained)
- [MetaMask Tutorial](https://www.youtube.com/results?search_query=metamask+tutorial+beginners)
- [wagmi Tutorial](https://www.youtube.com/results?search_query=wagmi+tutorial)

### 도구
- [Base Sepolia Faucet](https://www.alchemy.com/faucets/base-sepolia)
- [Base Sepolia Block Explorer](https://sepolia.basescan.org)
- [Chainlist](https://chainlist.org/) - 쉬운 네트워크 추가

---

## 다음은?

**Chapter 29**에서는 **Farcaster Frames**를 만들 거예요 - Web3 액션을 할 수 있는 인터랙티브 소셜 미디어 포스트!

### 앞으로 사용할 스킬

여기서 배운 모든 것이 다음 챕터들의 **기초**예요:

| 배운 것 | Ch29에서 사용하는 방법 | Ch30에서 사용하는 방법 |
|---------|----------------------|----------------------|
| **지갑 연결** | Frame 사용자가 지갑 연결 | 프론트엔드가 당신의 컨트랙트에 연결 |
| **트랜잭션 보내기** | Frames가 민팅/팁 트리거 가능 | 당신의 컨트랙트 함수 호출 |
| **블록체인 읽기** | 사용자가 NFT 소유하는지 확인 | 컨트랙트 상태 읽기 |
| **IPFS 기초** | Frame 이미지 저장 | NFT 메타데이터 저장 |
| **wagmi/viem** | 같은 라이브러리 사용 | 같은 라이브러리 사용 |

### Chapter 29에서 달라지는 것

```
Chapter 28: 독립적인 dapp 만들기
           ↓
Chapter 29: 소셜 미디어 포스트 안에 dapp 만들기!
           - 앱 스토어 필요 없음
           - Farcaster를 통한 바이럴 배포
           - 사용자가 피드를 떠나지 않고 상호작용
```

> 💡 **미리보기**: Chapter 29에서는 인터랙티브 투표 Frame, 퀴즈 게임, 심지어 NFT를 민팅하는 Frame을 만들 거예요 - 모두 소셜 미디어 포스트에 임베딩!

---

<p align="center">
  <a href="../Chapter27-Team-Collaboration/README.ko.md">← 이전: 팀 협업</a> |
  <a href="../Chapter29-Farcaster-Frames/README.ko.md">다음: Farcaster Frames →</a>
</p>

---

<p align="center">
  <sub>Built with ❤️ by <a href="https://hashed.com">Hashed</a></sub>
</p>
